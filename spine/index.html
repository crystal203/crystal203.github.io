<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Spine Viewer with GIF Export</title>
  <style>
    body {
      margin: 0;
      background: #1e1e1e;
      color: white;
      font-family: sans-serif;
    }

    canvas {
      display: block;
      margin: 0 auto;
      background: #111;
      cursor: grab;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding: 10px;
      background: #2c2c2c;
    }

    .toolbar label,
    .export-panel label {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .slot-panel,
    .anim-panel,
    .export-panel {
      max-width: 1000px;
      margin: 10px auto;
      background: #2a2a2a;
      border-radius: 8px;
      padding: 15px;
      overflow-y: auto;
      max-height: 300px;
    }

    .slot-panel h3,
    .anim-panel h3,
    .export-panel h3 {
      margin-top: 0;
      text-align: center;
    }

    .slot-control {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .slot-control input[type=range] {
      flex: 1;
      margin-left: 10px;
    }

    .track-select {
      margin-bottom: 10px;
      text-align: center;
    }

    .export-group {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .export-group label {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-size: 14px;
      gap: 4px;
      color: #ddd;
    }

    .export-actions {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
    }

    input[type=number] {
      width: 80px;
    }

    button {
      padding: 6px 12px;
      cursor: pointer;
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
  </style>
</head>

<body>

  <canvas id="canvas" width="256" height="256"></canvas>

  <!-- 工具栏 -->
  <div class="toolbar">
    <label>资源:
      <select id="assetSelector"></select>
    </label>
    <label>画布:
      <select id="canvasSizeSelector">
        <option value="128x128">128×128</option>
        <option value="256x256" selected>256×256</option>
        <option value="512x512">512×512</option>
        <option value="1024x1024">1024×1024</option>
        <option value="1800x1600">1800×1600</option>
      </select>
    </label>
    <label>皮肤:
      <select id="skinSelector"></select>
    </label>
    <label>缩放:
      <input type="range" id="scaleSlider" min="0.1" max="3" step="0.1" value="1">
    </label>
    <label>速度:
      <input type="range" id="speedSlider" min="0" max="2" step="0.1" value="1">
    </label>
  </div>

  <!-- 动画轨道选择 -->
  <div class="anim-panel">
    <h3>动画轨道叠加</h3>
    <div id="trackSelectors"></div>
  </div>

  <!-- 插槽透明度控制 -->
  <div class="slot-panel">
    <h3>组件透明度调节</h3>
    <div id="slotSliders"></div>
  </div>

  <!-- 导出 GIF 设置 -->
  <div class="export-panel">
    <h3>导出动画为 GIF</h3>
    <div class="export-group">
      <label>帧率 (fps):
        <input type="number" id="exportFps" min="1" max="30" value="20">
      </label>
      <label>时长 (秒):
        <input type="number" id="exportDuration" min="0.1" step="0.1">
      </label>
      <label>背景色:
        <input type="color" id="exportBgColor" value="#00ff00">
      </label>
    </div>
    <div class="export-group">
      <label>宽度:
        <input type="number" id="exportWidth">
      </label>
      <label>高度:
        <input type="number" id="exportHeight">
      </label>
    </div>
    <div class="export-actions">
      <button id="refreshDefaultsBtn">重置默认</button>
      <button id="recordGifBtn">导出 GIF</button>
    </div>
  </div>

  <script src="assets/assets.js"></script>
  <script src="spine-webgl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gifshot@0.3.2/build/gifshot.min.js"></script>
  <script>
    const canvas = document.getElementById("canvas");
    const gl = canvas.getContext("webgl", { alpha: false });
    const renderer = new spine.webgl.SceneRenderer(canvas, gl);

    let assetManager, skeleton, state;
    let slotOpacityMap = {};
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let skeletonPos = { x: canvas.width / 2, y: canvas.height / 2 };
    let animationNames = [];

    renderer.camera.position.x = canvas.width / 2;
    renderer.camera.position.y = canvas.height / 2;

    function setNearestFilterForAtlas(atlas) {
      for (let page of atlas.pages) {
        gl.bindTexture(gl.TEXTURE_2D, page.texture.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }
    }

    function populateAssetSelector() {
      const selector = document.getElementById("assetSelector");
      selector.innerHTML = "";
      window.spineAssets.forEach(name => {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        selector.appendChild(option);
      });
      selector.addEventListener("change", () => loadSpineAsset(selector.value));
    }

    function populateSkinSelector(skins) {
      const selector = document.getElementById("skinSelector");
      selector.innerHTML = "";
      skins.forEach(skin => {
        const option = document.createElement("option");
        option.value = skin.name;
        option.textContent = skin.name;
        selector.appendChild(option);
      });
      selector.addEventListener("change", () => {
        skeleton.setSkinByName(selector.value);
        skeleton.setSlotsToSetupPose();
      });
    }

    function createTrackSelector(trackIndex) {
      const container = document.getElementById("trackSelectors");
      const div = document.createElement("div");
      div.className = "track-select";
      div.innerHTML = `
      <label>轨道 ${trackIndex}:
        <select data-track="${trackIndex}">
          <option value="">（不选）</option>
          ${animationNames.map(name => `<option value="${name}">${name}</option>`).join("")}
        </select>
      </label>
    `;
      const select = div.querySelector("select");
      select.addEventListener("change", handleTrackChange);
      container.appendChild(div);
    }

    function handleTrackChange(e) {
      const container = document.getElementById("trackSelectors");
      const allSelects = Array.from(container.querySelectorAll("select"));
      const currentIndex = parseInt(e.target.dataset.track);

      // 清除所有后续轨道选择器和动画轨道
      for (let i = allSelects.length - 1; i > currentIndex; i--) {
        allSelects[i].parentElement.parentElement.remove(); // 删除div
        state.clearTrack(i); // 清除动画
      }

      // 更新当前及之前的轨道动画
      state.clearTracks();
      for (let i = 0; i <= currentIndex; i++) {
        const sel = allSelects[i];
        if (sel && sel.value) {
          state.setAnimation(i, sel.value, true);
        }
      }

      // 如果当前有值，添加下一个轨道选择器（不超过动画数量）
      if (e.target.value && currentIndex + 1 < animationNames.length) {
        createTrackSelector(currentIndex + 1);
      }
    }

    function resetTrackSelectors(animations) {
      animationNames = animations.map(a => a.name);
      const container = document.getElementById("trackSelectors");
      container.innerHTML = "";
      createTrackSelector(0); // Start with track 0
    }

    function createSlotSliders(slots) {
      const container = document.getElementById("slotSliders");
      container.innerHTML = "";
      slotOpacityMap = {};
      slots.forEach(slot => {
        const id = `slot-${slot.data.name}`;
        slotOpacityMap[slot.data.name] = 1.0;
        const wrapper = document.createElement("div");
        wrapper.className = "slot-control";
        wrapper.innerHTML = `
        <label for="${id}">${slot.data.name}</label>
        <input type="range" id="${id}" min="0" max="1" step="0.01" value="1">
      `;
        container.appendChild(wrapper);
        const input = wrapper.querySelector("input");
        input.addEventListener("input", () => {
          slotOpacityMap[slot.data.name] = parseFloat(input.value);
        });
      });
    }

    function updateCanvasSize() {
      const [w, h] = document.getElementById("canvasSizeSelector").value.split("x").map(Number);
      canvas.width = w;
      canvas.height = h;
      gl.viewport(0, 0, w, h);
      renderer.camera.viewportWidth = w;
      renderer.camera.viewportHeight = h;
      renderer.camera.position.x = w / 2;
      renderer.camera.position.y = h / 2;
      skeletonPos.x = w / 2;
      skeletonPos.y = h / 2;
    }

    function loadSpineAsset(base) {
      /*assetManager = new spine.webgl.AssetManager(gl);
      assetManager.loadTextureAtlas(`${base}.atlas`);
      assetManager.loadText(`${base}.json`);

      function checkLoaded() {
        if (assetManager.isLoadingComplete()) {
          const atlas = assetManager.get(`${base}.atlas`);
          setNearestFilterForAtlas(atlas);
          const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
          const skeletonJson = new spine.SkeletonJson(atlasLoader);
          const skeletonData = skeletonJson.readSkeletonData(assetManager.get(`${base}.json`));

          skeleton = new spine.Skeleton(skeletonData);
          skeleton.setToSetupPose();
          skeleton.updateWorldTransform();

          populateSkinSelector(skeletonData.skins);
          resetTrackSelectors(skeletonData.animations);
          createSlotSliders(skeleton.slots);
          updateCanvasSize();

          state = new spine.AnimationState(new spine.AnimationStateData(skeleton.data));
          requestAnimationFrame(render);
          setExportDefaults();
        } else {
          requestAnimationFrame(checkLoaded);
        }
      }

      checkLoaded();*/
      assetManager = new spine.webgl.AssetManager(gl);

      assetManager.loadTextureAtlas(`assets/${base}.atlas`);
      assetManager.loadBinary(`assets/${base}.bytes`);

      function checkLoaded() {
        if (assetManager.isLoadingComplete()) {
          const atlas = assetManager.get(`assets/${base}.atlas`);
          setNearestFilterForAtlas(atlas);
          const atlasLoader = new spine.AtlasAttachmentLoader(atlas);

          // 使用二进制读取器
          const binary = new spine.SkeletonBinary(atlasLoader);
          const skeletonData = binary.readSkeletonData(assetManager.get(`assets/${base}.bytes`));

          skeleton = new spine.Skeleton(skeletonData);
          skeleton.setToSetupPose();
          skeleton.updateWorldTransform();

          populateSkinSelector(skeletonData.skins);
          resetTrackSelectors(skeletonData.animations);
          createSlotSliders(skeleton.slots);
          updateCanvasSize();

          state = new spine.AnimationState(new spine.AnimationStateData(skeleton.data));
          requestAnimationFrame(render);
          setExportDefaults();
        } else {
          requestAnimationFrame(checkLoaded);
        }
      }

      checkLoaded();
    }
    let lastFrameTime = performance.now();

    function render(now = performance.now()) {
      const delta = (now - lastFrameTime) / 1000; // 单位：秒
      lastFrameTime = now;

      const speed = parseFloat(document.getElementById("speedSlider").value);
      const scale = parseFloat(document.getElementById("scaleSlider").value);

      // 正确推进动画：用真实时间乘以 speed
      state.update(delta * speed);
      state.apply(skeleton);

      skeleton.scaleX = scale;
      skeleton.scaleY = scale;
      skeleton.x = skeletonPos.x;
      skeleton.y = skeletonPos.y;
      skeleton.updateWorldTransform();

      for (const slot of skeleton.slots) {
        const alpha = slotOpacityMap[slot.data.name];
        if (typeof alpha === 'number') {
          slot.color.a = alpha;
        }
      }

      renderer.begin();
      renderer.drawSkeleton(skeleton, true);
      renderer.end();

      requestAnimationFrame(render);
    }


    document.getElementById("canvasSizeSelector").addEventListener("change", updateCanvasSize);

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      canvas.style.cursor = "grabbing";
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        skeletonPos.x += dx;
        skeletonPos.y -= dy;
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
      }
    });
    document.getElementById("refreshDefaultsBtn").addEventListener("click", setExportDefaults);
    canvas.addEventListener("mouseup", () => { isDragging = false; canvas.style.cursor = "grab"; });
    canvas.addEventListener("mouseleave", () => { isDragging = false; canvas.style.cursor = "grab"; });

    window.addEventListener("DOMContentLoaded", () => {
      if (Array.isArray(window.spineAssets)) {
        populateAssetSelector();
        document.getElementById("assetSelector").dispatchEvent(new Event("change"));
      } else {
        alert("assets.js 中未定义 window.spineAssets");
      }
    });

    function setExportDefaults() {
      const speed = parseFloat(document.getElementById("speedSlider").value || "1");
      const fps = parseFloat(document.getElementById("exportFps").value || "20");

      let maxDuration = 0;
      for (let i = 0; i < state.tracks.length; i++) {
        const entry = state.getCurrent(i);
        if (entry?.animation?.duration) {
          maxDuration = Math.max(maxDuration, entry.animation.duration);
        }
      }

      const adjustedDuration = maxDuration > 0 ? maxDuration / speed : 3; // fallback = 3s

      document.getElementById("exportDuration").value = adjustedDuration.toFixed(2);
      document.getElementById("exportWidth").value = canvas.width;
      document.getElementById("exportHeight").value = canvas.height;
    }

    document.getElementById("recordGifBtn").addEventListener("click", () => {
      const btn = document.getElementById("recordGifBtn");
      btn.disabled = true;
      btn.textContent = "导出中...";

      const fps = parseInt(document.getElementById("exportFps").value);
      const duration = parseFloat(document.getElementById("exportDuration").value);
      const width = parseInt(document.getElementById("exportWidth").value);
      const height = parseInt(document.getElementById("exportHeight").value);
      const frames = Math.round(duration * fps);
      const speed = parseFloat(document.getElementById("speedSlider").value);

      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      const frameList = [];

      // 获取背景颜色
      const bgColorHex = document.getElementById("exportBgColor").value;
      const r = parseInt(bgColorHex.slice(1, 3), 16) / 255;
      const g = parseInt(bgColorHex.slice(3, 5), 16) / 255;
      const b = parseInt(bgColorHex.slice(5, 7), 16) / 255;

      let frame = 0;
      function captureFrame() {
        state.update((1 / fps) * speed);
        state.apply(skeleton);
        skeleton.updateWorldTransform();

        // 使用自定义背景色清除主画布
        gl.clearColor(r, g, b, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        renderer.begin();
        renderer.drawSkeleton(skeleton, true);
        renderer.end();

        tempCtx.clearRect(0, 0, width, height);
        tempCtx.drawImage(canvas, 0, 0, width, height);
        frameList.push(tempCanvas.toDataURL("image/png"));

        if (++frame < frames) {
          requestAnimationFrame(captureFrame);
        } else {
          gifshot.createGIF({
            images: frameList,
            gifWidth: width,
            gifHeight: height,
            interval: 1 / fps,
            numFrames: frames,
            repeat: 0,
            frameDuration: 1,
            sampleInterval: 1
          }, function (result) {
            btn.disabled = false;
            btn.textContent = "导出 GIF";
            if (!result.error) {
              const link = document.createElement("a");
              link.href = result.image;
              link.download = "spine_export.gif";
              link.click();
            } else {
              alert("导出失败: " + result.errorMsg);
            }
          });
        }
      }

      captureFrame();
    });
  </script>
</body>

</html>