<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åœ†å½¢è§’æ–—åœºè®¡ç®—å™¨</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --blue-primary: #1E88E5;
            --blue-light: #BBDEFB;
            --blue-dark: #0D47A1;
            --red-primary: #E53935;
            --red-light: #FFCDD2;
            --red-dark: #B71C1C;
            --neutral-bg: #F5F5F5;
            --card-bg: #FFFFFF;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --border-radius: 12px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #f0f4f8 0%, #e6e9ef 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        html,
        body {
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .map-section {
            text-align: center;
        }

        .map-section .map-container {
            text-align: initial;
        }

        .info-panel {
            margin-top: 30px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            font-size: 14px;
            line-height: 1.6;
        }

        .info-header {
            background: linear-gradient(90deg, #66BB6A, #2E7D32);
            color: white;
            padding: 14px 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-header i {
            font-size: 1.3rem;
        }

        .info-content {
            padding: 20px;
            color: #555;
        }

        .info-content ul {
            padding-left: 24px;
            margin: 8px 0;
        }

        .info-content li {
            margin-bottom: 10px;
            position: relative;
        }

        .info-content li::before {
            content: "â€¢";
            color: #4CAF50;
            font-weight: bold;
            position: absolute;
            left: -18px;
            font-size: 1.4rem;
            line-height: 1;
        }

        .info-content strong {
            color: #2E7D32;
            font-weight: 600;
        }

        .info-content i {
            color: #1E88E5;
            margin: 0 2px;
        }

        @media (max-width: 768px) {
            .map-section {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding: 0 10px;
            }

            .map-container {
                min-width: auto !important;
                max-width: fit-content;
                display: inline-block;
            }

            .map {
                grid-template-columns: repeat(14, 32px);
                grid-template-rows: repeat(5, 32px);
                gap: 1px;
                padding: 4px;
                margin: 0;
            }

            .cell {
                width: 32px;
                height: 32px;
                font-size: 9px;
                border-radius: 4px;
                position: relative;
            }

            .cell-type {
                font-size: 5px;
            }

            .role-item {
                width: 64px;
                height: 86px;
            }

            .role-item .avatar {
                width: 30px;
                height: 30px;
                font-size: 11px;
            }

            .role-item .name {
                font-size: 9px;
                height: 20px;
            }

            .role-item .type {
                font-size: 7px;
            }

            .info-panel {
                margin-top: 20px;
            }

            .info-content {
                padding: 16px;
                font-size: 13px;
            }

            .info-content li {
                margin-bottom: 8px;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--blue-dark), var(--red-dark));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .header p {
            font-size: 1.1rem;
            color: #666;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .zone-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            background: var(--card-bg);
            box-shadow: var(--shadow);
            font-weight: 600;
            font-size: 1.3rem;
        }

        .zone-header.blue {
            color: var(--blue-dark);
            border-left: 4px solid var(--blue-primary);
        }

        .zone-header.red {
            color: var(--red-dark);
            border-left: 4px solid var(--red-primary);
        }

        .zone-header i {
            font-size: 1.4rem;
        }

        .order-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 30px;
        }

        .order-panel {
            flex: 1;
            max-width: 500px;
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--shadow);
            border: 2px solid transparent;
        }

        .order-panel.blue {
            border-color: var(--blue-light);
        }

        .order-panel.red {
            border-color: var(--red-light);
        }

        .order-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .blue .order-title {
            color: var(--blue-dark);
        }

        .red .order-title {
            color: var(--red-dark);
        }

        .order-list {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            min-height: 100px;
        }

        .role-item {
            width: 85px;
            height: 110px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: var(--transition);
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
        }

        .role-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }

        .role-item.highlight {
            border-color: gold;
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3);
            background: #fff9c4;
        }

        .blue .role-item {
            border-color: var(--blue-light);
        }

        .red .role-item {
            border-color: var(--red-light);
        }

        .role-item .avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 0%);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 6px;
            font-weight: bold;
            color: white;
            font-size: 16px;
        }

        .blue .role-item .avatar {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .red .role-item .avatar {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        .role-item .name {
            font-size: 10px;
            font-weight: 600;
            text-align: center;
            padding: 0 4px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .role-item .type {
            font-size: 8px;
            opacity: 0.7;
            margin-top: 2px;
        }

        .role-item .swap-btn {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            border: 2px solid var(--blue-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: var(--transition);
        }

        .blue .role-item .swap-btn:hover {
            background: var(--blue-primary);
            color: white;
            transform: translateX(-50%) scale(1.1);
        }

        .red .role-item .swap-btn {
            border-color: var(--red-primary);
        }

        .red .role-item .swap-btn:hover {
            background: var(--red-primary);
            color: white;
            transform: translateX(-50%) scale(1.1);
        }

        .role-item:first-child .swap-btn {
            display: none;
        }

        .map-title {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.5rem;
            color: #444;
            font-weight: 600;
        }

        .map-container {
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.1);
            display: inline-block;
            padding: 20px;
        }

        .map,
        .cell {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
        }

        .map {
            display: grid;
            grid-template-columns: repeat(14, 46px);
            grid-template-rows: repeat(5, 46px);
            gap: 4px;
            background: var(--neutral-bg);
            border-radius: 10px;
            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.08);
            padding: 0;
            margin: 0 auto;
        }

        .cell {
            width: 46px;
            height: 46px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: var(--transition);
            border: 2px solid transparent;
            background: white;
        }

        .cell:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .blue-zone {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid var(--blue-light);
        }

        .red-zone {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border: 2px solid var(--red-light);
        }

        .neutral-zone {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
        }

        .occupied,
        .red-occupied {
            transform: scale(1.02);
        }

        .occupied {
            background: linear-gradient(135deg, #90caf9 0%, #64b5f6 100%);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .red-occupied {
            background: linear-gradient(135deg, #ef9a9a 0%, #e57373 100%);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .highlight {
            box-shadow: 0 0 0 4px gold, 0 0 12px rgba(255, 215, 0, 0.6);
            transform: scale(1.1) !important;
            z-index: 10;
        }

        .cell-type {
            font-size: 8px;
            opacity: 0.8;
            margin-top: 2px;
        }

        .unlocked-marker {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #FF5722;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
            z-index: 5;
        }

        .arrow-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .role-select {
            background: white;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .overlay.active .role-select {
            transform: scale(1);
        }

        .modal-header {
            background: linear-gradient(90deg, var(--blue-primary), var(--red-primary));
            color: white;
            padding: 20px;
            text-align: center;
        }

        .modal-header h3 {
            font-size: 1.4rem;
            font-weight: 600;
        }

        .modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .roles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
        }

        .role-option {
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid #e0e0e0;
            background: #fafafa;
        }

        .role-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            border-color: var(--blue-primary);
        }

        .role-option .name {
            font-weight: 700;
            margin-bottom: 6px;
            font-size: 1.1rem;
            color: #333;
        }

        .role-option .type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 6px;
            margin-bottom: 4px;
        }

        .type-warrior {
            background: #ffecb3;
            color: #5d4037;
        }

        .type-support {
            background: #c8e6c9;
            color: #1b5e20;
        }

        .type-archer {
            background: #bbdefb;
            color: #0d47a1;
        }

        .type-tank {
            background: #fbbbf2;
            color: #a10d5e;
        }

        .role-option .ai {
            font-size: 0.85rem;
            color: #666;
            font-style: italic;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #eee;
            text-align: right;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            font-size: 1rem;
        }

        .btn-cancel {
            background: #f5f5f5;
            color: #666;
            margin-right: 10px;
        }

        .btn-cancel:hover {
            background: #e0e0e0;
        }

        .btn-confirm {
            background: var(--blue-primary);
            color: white;
        }

        .btn-confirm:hover {
            background: var(--blue-dark);
            transform: translateY(-2px);
        }

        .zone-label {
            position: absolute;
            top: -30px;
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .blue-label {
            left: 10px;
            color: var(--blue-dark);
        }

        .red-label {
            right: 10px;
            color: var(--red-dark);
        }

        .neutral-label {
            left: 50%;
            transform: translateX(-50%);
            color: #757575;
        }

        @media (max-width: 1200px) {
            .order-container {
                flex-direction: column;
                align-items: center;
            }

            .order-panel {
                width: 100%;
                max-width: 600px;
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .role-item.new {
            animation: fadeInUp 0.4s ease-out;
        }

        .cell.pending-move-source {
            box-shadow: 0 0 0 4px gold, 0 0 0 8px rgba(30, 136, 229, 0.2), 0 0 12px rgba(255, 215, 0, 0.6);
            transform: scale(1.12) !important;
            z-index: 20;
            position: relative;
        }

        .highlight.pending-move-source {
            transform: scale(1.12) !important;
        }
    </style>
</head>

<body>
    <script type="module" src="./ruleEngine.js"></script>
    <script type="module" src="./simEngine.js"></script>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-chess"></i> åœ†å½¢è§’æ–—åœºè®¡ç®—å™¨</h1>
        </div>

        <div id="scorePanel" style="
                position: fixed;
                top: 20px;
                left: 20px;
                max-width: 320px;
                background: white;
                border-radius: 12px;
                box-shadow: 0 6px 20px rgba(0,0,0,0.15);
                z-index: 999;
                font-size: 13px;
                display: none;
            ">
            <div style="
                    background: linear-gradient(90deg, #1E88E5, #E53935);
                    color: white;
                    padding: 10px 16px;
                    font-weight: 600;
                    border-radius: 12px 12px 0 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                ">
                <span><i class="fas fa-trophy"></i> æˆ˜æœ¯è¯„åˆ†</span>
                <button onclick="document.getElementById('scorePanel').style.display='none'"
                    style="background: none; border: none; color: white; font-size: 16px; cursor: pointer;">Ã—</button>
            </div>
            <div id="scoreContent" style="padding: 12px;"></div>
        </div>

        <div style="margin-top: 12px; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
            <label
                style="display: flex; align-items: center; gap: 6px; background: white; padding: 8px 15px; border-radius: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                <input type="checkbox" id="showAvatars" checked>
                <i class="fas fa-user-circle"></i>
                <span>æ˜¾ç¤ºè§’è‰²å¤´åƒ</span>
            </label>

            <label
                style="display: flex; align-items: center; gap: 6px; background: white; padding: 8px 15px; border-radius: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                <input type="checkbox" id="showDualArrows" checked>
                <i class="fas fa-exchange-alt"></i>
                <span>åˆå¹¶äº’é”ç®­å¤´</span>
            </label>
        </div>
        </br>

        <div id="tacticPanel" style="
                display: none;
                margin: 20px auto;
                max-width: 1000px;
                background: white;
                border-radius: 12px;
                box-shadow: var(--shadow);
                overflow: hidden;
            ">
            <div style="
                    background: linear-gradient(90deg, #1E88E5, #7B1FA2);
                    color: white;
                    padding: 14px 20px;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                ">
                <i class="fas fa-microchip"></i>
                <span>æ™ºèƒ½æˆ˜æœ¯æ¨è</span>
            </div>
            <div id="tacticContent" style="padding: 16px;"></div>
        </div>

        <div class="order-container">
            <div class="order-panel blue">
                <div class="zone-header blue">
                    <i class="fas fa-gun"></i>
                    <span>æˆ‘æ–¹é˜µå®¹</span>
                </div>
                <div class="order-list" id="blueOrder"></div>
            </div>
            <div class="order-panel red">
                <div class="zone-header red">
                    <i class="fas fa-shield-alt"></i>
                    <span>æ•Œæ–¹é˜µå®¹</span>
                </div>
                <div class="order-list" id="redOrder"></div>
            </div>
        </div>

        <div class="map-section">
            <div class="map-container">
                <div class="map" id="map"></div>
                <div class="arrow-layer" id="arrowLayer"></div>
                <div id="simDimMask" style="
                    position: absolute;
                    top: 0; left: 0;
                    width: 100%; height: 100%;
                    background: rgba(255, 255, 255, 0.7); /* ç™½åº•æŸ”å…‰é®ç½©ï¼Œå¯æ”¹ rgba(0,0,0,0.4) æš—è‰² */
                    pointer-events: none;
                    z-index: 19;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                "></div>
                <!-- âœ… æ–°å¢ï¼šæ¨¡æ‹Ÿå¯è§†åŒ–è¦†ç›–å±‚ -->
                <div id="simOverlay" style="
                    position: absolute;
                    top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none;
                    z-index: 20;
                "></div>
            </div>
            <!-- âœ… å¿…é¡»ï¼šsimOverlay æ”¾åœ¨ map-container å†…æ‰èƒ½ relative å®šä½ï¼ -->
            <div id="simOverlay" style="
                position: absolute;
                top: 0; left: 0;
                width: 100%; height: 100%;
                pointer-events: none;
                z-index: 20;
                display: none;
            "></div>
        </div>

        <div style="margin-top: 12px; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">

            <label
                style="display: flex; align-items: center; gap: 6px; background: white; padding: 8px 15px; border-radius: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                <input type="checkbox" id="simulateDrag">
                <i class="fas fa-mobile-alt"></i>
                <span>æ¨¡æ‹Ÿæ‹–åŠ¨</span>
            </label>
        </div>
        <div style="margin-top: 12px; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
            <button id="btnSimulate" class="btn btn-confirm"
                style="padding: 10px 24px; font-size: 1.1rem;">
                <i class="fas fa-play"></i> å¯¹å±€æ¨¡æ‹Ÿï¼ˆæµ‹è¯•ï¼‰
            </button>
            <button id="btnStopSimulate" class="btn btn-cancel"
                style="padding: 10px 24px; font-size: 1.1rem; display: none;">
                <i class="fas fa-stop"></i> åœæ­¢æ¨¡æ‹Ÿ
            </button>
            <button id="btnReplaySimulate" class="btn"
                style="background: #6a11cb; color: white; display: none;">
                <i class="fas fa-redo"></i> é‡æ’­
            </button>
        </div>
        <div class="info-panel" id="infoPanel">
            <div class="info-header">
                <i class="fas fa-info-circle"></i>
                <span>ä½¿ç”¨è¯´æ˜</span>
            </div>
            <div class="info-content">
                <ul>
                    <li><strong>è§’è‰²å¸ƒç½®</strong>ï¼šç‚¹å‡»å·±æ–¹/æ•Œæ–¹åŒºåŸŸç©ºæ ¼ â†’ é€‰æ‹©è§’è‰²ï¼›ç‚¹å‡»å·²æœ‰è§’è‰² â†’ ç§»é™¤ã€‚</li>
                    <li><strong>é˜µå®¹è°ƒæ•´</strong>ï¼šç‚¹å‡»è§’è‰²å¡ä¸‹æ–¹ <i class="fas fa-exchange-alt"></i> æŒ‰é’®å¯ä¸å‰ä¸€ä½äº¤æ¢é¡ºåºã€‚</li>
                    <li><strong>æ‹–æ‹½æ“ä½œ</strong>ï¼šæŒ‰ä½è§’è‰²æ ¼æ‹–åŠ¨ â†’ å¯åœ¨åŒé˜µè¥å†…ç§»åŠ¨æˆ–äº¤æ¢ä½ç½®ã€‚</li>
                    <li><strong>æ¨¡æ‹Ÿæ‹–åŠ¨</strong>ï¼šï¼ˆæ¨èç§»åŠ¨ç«¯ï¼‰å‹¾é€‰åæ‹–æ‹½æ“ä½œæ”¹ä¸ºã€Œç‚¹å‡»æº â†’ ç‚¹å‡»ç›®æ ‡ã€ä¸¤æ­¥æ“ä½œã€‚</li>
                    <li><strong>ç´¢æ•Œä¼˜åŒ–</strong>ï¼šè‹¥ Aâ†’B ä¸” Bâ†’Aï¼Œå‹¾é€‰ã€Œåˆå¹¶äº’é”ç®­å¤´ã€å¯æ˜¾ç¤ºä¸ºåŒå‘ç´«è‰²ç®­å¤´ã€‚æ²¡æœ‰è¢«é”çš„è§’è‰²ä¼šæœ‰çº¢è‰²æ„Ÿå¹å·æ ‡æ³¨ã€‚</li>
                    <li><strong>æ™ºèƒ½æ¨è</strong>ï¼šå½“æ•Œæ–¹é˜µå®¹ç¬¦åˆé¢„è®¾æ¨¡æ¿æ—¶æ˜¾ç¤ºï¼Œç‚¹å‡» <i class="fas fa-bolt"></i> ç½®å…¥é¢„è®¾æ¨èã€‚</li>
                    <li><strong>æˆ˜æœ¯è¯„åˆ†</strong>ï¼šå¦‚æœä½¿ç”¨é¢„è®¾çš„æ”»é˜²é˜µå®¹ï¼Œçª—å£ <i class="fas fa-trophy"></i> å°†æ˜¾ç¤ºå½“å‰è¿›æ”»æ‘†ä½çš„åˆç†ç¨‹åº¦ã€‚</li>
                    <li><strong>è‡ªåŠ¨æ‘†ä½</strong>ï¼šåœ¨æ™ºèƒ½æ¨èä¸‹ï¼Œç‚¹å‡» <i class="fas fa-magic"></i>
                        è¿›è¡Œè‡ªåŠ¨æ‘†ä½ã€‚è‡ªåŠ¨æ‘†ä½å°†æœ€å¤§åŒ–æˆ˜æœ¯è¯„åˆ†ã€‚å»ºè®®åœ¨ä¸é™ä½æˆ˜æœ¯è¯„åˆ†çš„å‰æä¸‹å¾®è°ƒç«™ä½ã€‚</li>
                    <li><strong>è§„åˆ™è¯­æ³•</strong>ï¼šæˆ˜æœ¯è¯„åˆ†çš„è§„åˆ™åŸºäºç‰¹å®šçš„è§„åˆ™è¯­æ³•ã€‚å¯æŸ¥é˜… ./rule/example.js ç¤ºä¾‹å’Œ ./grammar.txt è¯­æ³•æ ‘ã€‚</li>
                </ul>
                <div style="
                    margin-top: 20px;
                    padding-top: 16px;
                    border-top: 1px dashed #e0e0e0;
                    font-size: 13px;
                    color: #777;
                    display: flex;
                    flex-wrap: wrap;
                    align-items: center;
                    gap: 12px;
                ">
                    <span>
                        <i class="fas fa-code-branch" style="color: #66BB6A; margin-right: 4px;"></i>
                        <strong>ç‰ˆæœ¬</strong>: 2025.11.12 | v1.1
                    </span>
                    <span>
                        <i class="fas fa-user" style="color: #2196F3; margin-right: 4px;"></i>
                        <strong>ä½œè€…</strong>: crystal302
                    </span>
                    <span>
                        <i class="fas fa-envelope" style="color: #FB8C00; margin-right: 4px;"></i>
                        <a href="mailto:realzombie462@gmail.com"
                            style="color: #555; text-decoration: none; border-bottom: 1px dotted #999;"
                            onmouseover="this.style.color='#FB8C00'" onmouseout="this.style.color='#555'">
                            realzombie462@gmail.com
                        </a>
                    </span>
                    <span>
                        <i class="fab fa-bilibili" style="color: #FB7299; margin-right: 4px;"></i>
                        <a href="https://space.bilibili.com/500388576" target="_blank"
                            style="color: #555; text-decoration: none; border-bottom: 1px dotted #FB7299;"
                            onmouseover="this.style.color='#FB7299'" onmouseout="this.style.color='#555'">
                            @zombie462
                        </a>
                    </span>
                </div>
            </div>
        </div>
    </div>
    <div class="overlay" id="overlay">
        <div class="role-select">
            <div class="modal-header">
                <h3><i class="fas fa-user-plus"></i> é€‰æ‹©è§’è‰²</h3>
            </div>
            <div class="modal-body">
                <div class="roles-grid" id="roleOptions"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-cancel" onclick="closeRoleSelect()">å–æ¶ˆ</button>
            </div>
        </div>

        <script>
            // ===== é¢„è®¾è§’è‰²åº“ =====
            document.addEventListener('dragstart', e => {
                if (e.target.tagName === 'IMG' || e.target.closest('.role-option')) {
                    e.preventDefault();
                }
            }, true);
            const ALL_ROLES = [
                { name: "å‡¯å‹’", type: "æˆ˜å£«", ai: "è¾…åŠ©åˆºå®¢ai", short: "Kahlor", color: "#FF5722", 
                    speed: 2.5 * 1.66, reach: 0.2, skillRange: 4.00, skillCastTime: 0.00, skillDashDist: 4.00, skillDashSpeed: 10.00, resistA: 3, resistB: 4, resistC: 100 },
                { name: "è‰è€¶", type: "æˆ˜å£«", ai: "å°„æ‰‹åˆºå®¢ai", short: "Rie", color: "#607D8B", 
                    speed: 2.5 * 1.66, reach: 0.2, skillRange: 5.66, skillCastTime: 0.75, skillDashDist: 5.00, skillDashSpeed: 10.00, resistA: 1, resistB: 2, resistC: 100 },
                { name: "è´ä¸", type: "æˆ˜å£«", ai: "å°„æ‰‹åˆºå®¢ai", short: "Beth", color: "#9C27B0", 
                    speed: 2.5 * 1.7, reach: 0.2, skillRange: 4.00, skillCastTime: 0.66, skillDashDist: 4.00, skillDashSpeed: 10.00, resistA: 1, resistB: 2, resistC: 1 },
                { name: "ä¼Šå¨ƒ", type: "è¾…åŠ©", ai: "è¿‘æˆ˜ai", short: "Eva", color: "#607D8B", 
                    speed: 2.5, reach: 6.33, resistA: 1, resistB: 2, resistC: 100 },
                { name: "é»›è¥¿", type: "å¦å…‹", ai: "è¿‘æˆ˜ai", short: "Daisy", color: "#2196F3", 
                    speed: 2.5 * 1.5, reach: 0.2, skillRange: 5.00, tauntRadius: 4.50, skillCastTime: 0.33, skillDashDist: 5.00, skillDashSpeed: 10.00,
                    resistA: 2, resistB: 3, resistC: 1 },
                { name: "é“¶æ²³", type: "å°„æ‰‹", ai: "è¿œç¨‹ai", short: "Eunha", color: "#607D8B", 
                    speed: 2.5, reach: 5.00, resistA: 1, resistB: 2, resistC: 100 },
                { name: "è‰¾ä¸é»›å°”", type: "å°„æ‰‹", ai: "è¿‘æˆ˜ai", short: "Estel", color: "#795548",
                    speed: 2.5, reach: 7.00, resistA: 1, resistB: 2, resistC: 100 },
                { name: "é˜¿æ‹‰è´å°”", type: "å°„æ‰‹", ai: "è¿œç¨‹ai", short: "Arabelle", color: "#9C27B0",
                    speed: 2.5, reach: 6.50, resistA: 1, resistB: 2, resistC: 100 },
                { name: "å¡è‰", type: "æˆ˜å£«", ai: "è¿‘æˆ˜ai", short: "Callie", color: "#9C27B0" , 
                    speed: 2.5 * 1.6, reach: 0.2, skillRange: 4.00, skillCastTime: 0.00, skillDashDist: 4.00, skillDashSpeed: 10.00, resistA: 1, resistB: 2, resistC: 100 },
                { name: "ç¾å¨…", type: "è¾…åŠ©", ai: "å°±è¿‘åˆºå®¢ai", short: "Miya", color: "#FF5722",
                    speed: 2.5, reach: 7.00, resistA: 1, resistB: 2, resistC: 100 },
                { name: "åŠ ç™¾åˆ—", type: "è¾…åŠ©", ai: "è¿œç¨‹ai", short: "Gabriel", color: "#FF9800",
                    speed: 2.5, reach: 5.00, resistA: 1, resistB: 2, resistC: 100 },
                { name: "å¡éº¦å°”", type: "è¾…åŠ©", ai: "è¿œç¨‹ai", short: "Kamael", color: "#795548" ,
                    speed: 2.5, reach: 3.50, resistA: 1, resistB: 2, resistC: 100 },
                { name: "J", type: "å°„æ‰‹", ai: "è¿œç¨‹ai", short: "J", color: "#2196F3" },
                { name: "æœªæ¥éª‘å£«", type: "æˆ˜å£«", ai: "è¿œç¨‹ai", short: "FKnight", color: "#607D8B" },
                { name: "æ±é›…", type: "è¾…åŠ©", ai: "è¿œç¨‹ai", short: "Sia", color: "#2196F3" },
                { name: "ç»´ç½—å¦®å¡", type: "è¾…åŠ©", ai: "è¿‘æˆ˜ai", short: "Veronica", color: "#2196F3" },
                { name: "æ¯”å®‰å¡", type: "å°„æ‰‹", ai: "è¿œç¨‹ai", short: "Bianca", color: "#2196F3" },
                { name: "æœªæ¥å…¬ä¸»", type: "å¦å…‹", ai: "è¿‘æˆ˜ai", short: "FPrincess", color: "#FF9800" },
                // å…‰ FF9800 æš— 9C27B0 è™š 607D8B æ°´ 2196F3 ç« FF5722 åœŸ 795548
            ];
            /*
                ALL_ROLES.forEach(role => {
                    if (role.speed === undefined) {
                        role.speed = 1.0;
                        role.reach = 0.2;
                        role.skillRange = -1;
                        role.skillCastTime = 0.0;
                        role.skillDashSpeed = 0.0;
                        role.skillDashDist = 0.0;
                        role.tauntRadius = 0;
                        role.resistA = 1; role.resistB = 2; role.resistC = 100;
                    }
                });
            */

            // ===== çŠ¶æ€ç®¡ç† =====
            const STATE = {
                map: Array(5).fill().map(() => Array(14).fill(null)),
                redOrder: [],
                blueOrder: []
            };

            const mapEl = document.getElementById('map');
            const redOrderEl = document.getElementById('redOrder');
            const blueOrderEl = document.getElementById('blueOrder');
            const arrowLayer = document.getElementById('arrowLayer');
            const overlay = document.getElementById('overlay');
            let roleOptions = document.getElementById('roleOptions');

            let selectedCell = null;
            let simulateDragMode = false;
            let pendingMoveUnit = null;
            let pendingMoveCell = null;
            let pendingRole = null;

            // ===== åˆå§‹åŒ–åœ°å›¾ =====
            function initMap() {
                mapEl.innerHTML = '';
                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 14; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        if (c < 4) cell.classList.add('blue-zone');
                        else if (c >= 10) cell.classList.add('red-zone');
                        else cell.classList.add('neutral-zone');
                        // æ·»åŠ åŒºåŸŸæ ‡ç­¾
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.addEventListener('mousedown', (e) => {
                            if (e.button !== 0) return;
                            if (document.getElementById('simulateDrag')?.checked) return;
                            handleDragStart(e, r, c);
                        });
                        cell.addEventListener('touchstart', (e) => {
                            if (e.touches.length === 1) {
                                if (document.getElementById('simulateDrag')?.checked) return;
                                const touch = e.touches[0];
                                dragState.touchStartX = touch.clientX;
                                dragState.touchStartY = touch.clientY;
                                dragState.isScrolling = false;
                            }
                        }, { passive: false });
                        cell.addEventListener('touchmove', (e) => {
                            if (e.touches.length !== 1 || dragState.isScrolling) return;
                            const touch = e.touches[0];
                            const dx = Math.abs(touch.clientX - dragState.touchStartX);
                            const dy = Math.abs(touch.clientY - dragState.touchStartY);
                            // å‚ç›´æ»šåŠ¨ä¼˜å…ˆï¼šå½“ dy > dx æ—¶è§†ä¸ºæ»šåŠ¨
                            if (dy > dx) {
                                dragState.isScrolling = true;
                                return;
                            }
                            // æ°´å¹³æ‹–æ‹½ï¼šé˜»æ­¢é»˜è®¤æ»šåŠ¨
                            e.preventDefault();
                            handleDragMove(touch);
                        }, { passive: false });
                        // æ¢å¤å•å‡»åŠŸèƒ½ï¼šæ·»åŠ  click äº‹ä»¶ï¼ˆåŸé€»è¾‘ï¼‰
                        cell.addEventListener('click', (e) => {
                            // å¦‚æœæ˜¯æ‹–æ‹½æ“ä½œï¼Œä¸è§¦å‘ç‚¹å‡»
                            if (Date.now() - (dragState.lastDragEndTime || 0) < 300) return;
                            handleCellClick(r, c);
                        });
                        // æ·»åŠ å…¨å±€æ‹–æ‹½ç›‘å¬
                        document.addEventListener('mousemove', handleDragMove);
                        document.addEventListener('mouseup', handleDragEnd);
                        document.addEventListener('touchend', handleDragEnd);
                        mapEl.appendChild(cell);
                    }
                }
                renderMap();
            }

            function renderMap() {
                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 14; c++) {
                        const cell = mapEl.children[r * 14 + c];
                        const unit = STATE.map[r][c];
                        cell.className = 'cell';
                        if (c < 4) cell.classList.add('blue-zone');
                        else if (c >= 10) cell.classList.add('red-zone');
                        else cell.classList.add('neutral-zone');
                        // æ¸…ç©ºå†…å®¹å¹¶é‡æ–°æ·»åŠ åŒºåŸŸæ ‡ç­¾
                        cell.innerHTML = '';
                        if (r === 0) {
                            const label = document.createElement('div');
                            label.className = 'cell-type';
                            if (label.textContent) cell.appendChild(label);
                        }
                        if (unit) {
                            const cellContent = document.createElement('div');
                            cellContent.style.display = 'flex';
                            cellContent.style.flexDirection = 'column';
                            cellContent.style.alignItems = 'center';
                            cellContent.style.justifyContent = 'center';
                            cellContent.style.width = '100%';
                            cellContent.style.height = '100%';
                            cellContent.style.fontSize = '9px';
                            const showAvatars = document.getElementById('showAvatars').checked;
                            if (showAvatars) {
                                const img = document.createElement('img');
                                img.src = `./asset/${unit.role.short}.png`;
                                img.alt = unit.role.short;
                                img.style.width = '100%';
                                img.style.height = '100%';
                                img.style.objectFit = 'cover';
                                img.style.borderRadius = '4px';
                                img.style.marginBottom = '2px';
                                img.onerror = () => {
                                    img.style.display = 'none';
                                    cellContent.innerHTML = `<div style="font-weight:bold; margin-bottom:1px;">${unit.role.short}</div>`;
                                };
                                cellContent.appendChild(img);
                            } else {
                                cellContent.innerHTML = `<div style="font-weight:bold; margin-bottom:1px;">${unit.role.short}</div>`;
                            }
                            cell.appendChild(cellContent);
                            cell.classList.add(unit.side === 'red' ? 'red-occupied' : 'occupied');
                            if (unit === getFirstUnit(unit.side)) {
                                cell.classList.add('highlight');
                            }
                        }
                    }
                }
                const computedTargets = computeTargets();
                const lockedUnits = new Set();
                computedTargets.forEach(t => lockedUnits.add(t.to));
                const blockedUnits = new Set();
                const attackerToTarget = new Map(); // attacker â†’ target
                computedTargets.forEach(({ from, to }) => {
                    attackerToTarget.set(from, to);
                });

                const assassins = [...STATE.blueOrder, ...STATE.redOrder].filter(u =>
                    u.role.ai === 'è¾…åŠ©åˆºå®¢ai' || u.role.ai === 'å°„æ‰‹åˆºå®¢ai'
                );

                // æ„å»ºã€Œè°é”äº†è°ã€æ˜ å°„ï¼štarget â†’ [attackers]
                const lockers = new Map();
                computedTargets.forEach(({ from, to }) => {
                    if (!lockers.has(to)) lockers.set(to, []);
                    lockers.get(to).push(from);
                });

                assassins.forEach(attacker => {
                    const enemies = attacker.side === 'blue' ? STATE.redOrder : STATE.blueOrder;
                    const tanks = enemies.filter(u => u.role.type === 'å¦å…‹');
                    const victim = attackerToTarget.get(attacker); // attacker çš„ç›®æ ‡
                    if (!victim) return; // æ— ç›®æ ‡ â†’ æ— æ³•æ„æˆâ€œå¤¹åœ¨ä¸­é—´â€

                    const lockersOfAttacker = lockers.get(attacker) || [];
                    const tankLockers = lockersOfAttacker.filter(u => tanks.includes(u));

                    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå¦å…‹ï¼šåŒè¡Œ + é”å®šåˆºå®¢ + ä½äºåˆºå®¢ä¸ç›®æ ‡ä¹‹é—´
                    const [ar, ac] = attacker.pos;
                    const [vr, vc] = victim.pos;
                    for (const tank of tankLockers) {
                        const [tr, tc] = tank.pos;
                        // æ¡ä»¶3ï¼šåŒè¡Œ
                        if (tr !== ar) continue;
                        // æ¡ä»¶5ï¼šå¦å…‹åˆ—ä¸¥æ ¼ä»‹äºåˆºå®¢ä¸ç›®æ ‡ä¹‹é—´
                        if (Math.min(ac, vc) < tc && tc < Math.max(ac, vc)) {
                            blockedUnits.add(attacker);
                            break; // æ‰¾åˆ°ä¸€ä¸ªå³å¯
                        }
                    }
                });
                // ä¸ºæœªé”å®šè§’è‰²æ·»åŠ æ ‡è®°
                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 14; c++) {
                        const unit = STATE.map[r][c];
                        const cell = mapEl.children[r * 14 + c];
                        // ç§»é™¤æ—§æ ‡è®°
                        const oldMarker = cell.querySelector('.unlocked-marker');
                        if (oldMarker) oldMarker.remove();
                        // æ·»åŠ æ–°æ ‡è®°ï¼ˆä»…å½“å­˜åœ¨è§’è‰²ä¸”æœªè¢«é”å®šï¼‰
                        if (unit && !lockedUnits.has(unit)) {
                            const marker = document.createElement('div');
                            marker.className = 'unlocked-marker';
                            marker.innerHTML = '!';
                            cell.appendChild(marker);
                        }
                        if (unit && blockedUnits.has(unit)) {
                            const blockedMarker = document.createElement('div');
                            blockedMarker.className = 'unlocked-marker';
                            blockedMarker.style.cssText += `
                                left: 2px !important;
                                right: auto !important;
                                background: #607D8B !important;
                                width: 16px !important;
                                height: 16px !important;
                                font-size: 10px !important;
                            `;
                            blockedMarker.innerHTML = 'ğŸ”’';
                            blockedMarker.title = 'è¢«é˜»æŒ¡';
                            cell.appendChild(blockedMarker);
                        }
                    }
                }
                renderOrderLists();
                drawArrows();
                if (typeof checkAllRules === 'function') {
                    requestAnimationFrame(checkAllRules);
                }
            }

            function getFirstUnit(side) {
                const order = side === 'red' ? STATE.redOrder : STATE.blueOrder;
                return order.length > 0 ? order[0] : null;
            }

            // ===== å•å…ƒæ ¼ç‚¹å‡» =====
            function handleCellClick(r, c) {
                if (dragState.isActive || dragState.isClickPrevented) {
                    const preview = document.getElementById('drag-preview');
                    if (preview) preview.remove();
                    dragState = {
                        isActive: false,
                        isClickPrevented: false,
                        isScrolling: false,
                        touchStartX: 0,
                        touchStartY: 0,
                        startRow: -1,
                        startCol: -1,
                        currentRow: -1,
                        currentCol: -1,
                        draggedUnit: null,
                        validDropZone: null
                    };
                }
                if (Date.now() - (dragState.lastDragEndTime || 0) < 300) return;
                const unit = STATE.map[r][c];
                const side = c < 4 ? 'blue' : c >= 10 ? 'red' : null;
                if (!side) return;
                simulateDragMode = document.getElementById('simulateDrag')?.checked || false;
                // æ¨¡æ‹Ÿæ‹–åŠ¨æ¨¡å¼
                if (simulateDragMode) {
                    // è¿›å…¥å¾…ç§»åŠ¨çŠ¶æ€
                    if (unit && !pendingMoveUnit) {
                        pendingMoveUnit = unit;
                        pendingMoveCell = mapEl.children[r * 14 + c];
                        pendingMoveCell.classList.add('highlight', 'pending-move-source');
                        showNotification(`ğŸ“Œ è¯·ç‚¹å‡»ç›®æ ‡ä½ç½®æ”¾ç½® ${unit.role.name}`, 'info');
                        return;
                    }
                    // å·²æœ‰å¾…ç§»åŠ¨å•ä½
                    if (pendingMoveUnit) {
                        // ç‚¹å‡»è‡ªå·± â†’ å–æ¶ˆ
                        if (unit === pendingMoveUnit) {
                            cancelPendingMove();
                            showNotification('å·²å–æ¶ˆç§»åŠ¨', 'info');
                            return;
                        }
                        // æ£€æŸ¥æ˜¯å¦åŒé˜µè¥
                        if (pendingMoveUnit.side !== side) {
                            showNotification('âš ï¸ ä¸èƒ½è·¨é˜µè¥ç§»åŠ¨ï¼', 'warning');
                            cancelPendingMove();
                            return;
                        }
                        // åˆæ³•åŒé˜µè¥æ ¼å­ï¼šæ‰§è¡Œç§»åŠ¨/äº¤æ¢
                        const targetUnit = unit;
                        const srcR = pendingMoveUnit.pos[0];
                        const srcC = pendingMoveUnit.pos[1];
                        // --- æ‰§è¡Œæ“ä½œ ---
                        if (!targetUnit) {
                            // ç§»åŠ¨åˆ°ç©ºæ ¼
                            STATE.map[srcR][srcC] = null;
                            STATE.map[r][c] = pendingMoveUnit;
                            pendingMoveUnit.pos = [r, c];
                            showNotification(`âœ… ç§»åŠ¨ ${pendingMoveUnit.role.name} åˆ° (${r + 1},${c + 1})`, 'success');
                        } else {
                            // åŒé˜µè¥äº¤æ¢
                            STATE.map[srcR][srcC] = targetUnit;
                            STATE.map[r][c] = pendingMoveUnit;
                            pendingMoveUnit.pos = [r, c];
                            targetUnit.pos = [srcR, srcC];
                            showNotification(`ğŸ”„ äº¤æ¢ ${pendingMoveUnit.role.name} ä¸ ${targetUnit.role.name}`, 'success');
                        }
                        renderMap();
                        cancelPendingMove();
                        return;
                    }
                }
                // éæ¨¡æ‹Ÿæ‹–åŠ¨æ¨¡å¼
                if (unit) {
                    removeUnit(r, c);
                } else {
                    const order = side === 'red' ? STATE.redOrder : STATE.blueOrder;
                    if (order.length >= 4) {
                        showNotification(`æœ€å¤šå¸ƒç½®4ä¸ª${side === 'red' ? 'æ•Œæ–¹' : 'æˆ‘æ–¹'}è§’è‰²ï¼`, 'warning');
                        return;
                    }
                    selectedCell = { row: r, col: c, side };
                    openRoleSelect();
                }
            }

            function cancelPendingMove() {
                if (pendingMoveCell) {
                    pendingMoveCell.classList.remove('highlight', 'pending-move-source');
                }
                pendingMoveUnit = null;
                pendingMoveCell = null;
            }

            function openRoleSelect() {
                // ===== å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶è¿˜åŸ overlay åˆ°æ ‡å‡†è§’è‰²é€‰æ‹©é¢æ¿ç»“æ„ =====
                overlay.innerHTML = `
                    <div class="role-select">
                        <div class="modal-header">
                            <h3><i class="fas fa-user-plus"></i> é€‰æ‹©è§’è‰²</h3>
                        </div>
                        <div class="modal-body">
                            <div class="roles-grid" id="roleOptions"></div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-cancel" onclick="closeRoleSelect()">å–æ¶ˆ</button>
                        </div>
                    </div>
                `;
                roleOptions = document.getElementById('roleOptions'); // é‡æ–°ç»‘å®šï¼

                // ===== æ­£å¸¸æ¸²æŸ“è§’è‰² =====
                ALL_ROLES.forEach(role => {
                    const div = document.createElement('div');
                    div.className = 'role-option';
                    const isDuplicate = selectedCell &&
                        ((selectedCell.side === 'blue' && STATE.blueOrder.some(u => u.role.short === role.short)) ||
                            (selectedCell.side === 'red' && STATE.redOrder.some(u => u.role.short === role.short)));
                    if (isDuplicate) {
                        div.style.opacity = '0.4';
                        div.style.pointerEvents = 'none';
                        div.style.position = 'relative';
                    }
                    const typeClass = role.type === 'æˆ˜å£«' ? 'type-warrior' :
                        role.type === 'å¦å…‹' ? 'type-tank' :
                            role.type === 'è¾…åŠ©' ? 'type-support' : 'type-archer';
                    div.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 40px; height: 40px; border-radius: 6px; overflow: hidden; flex-shrink: 0;">
                                <img src="./asset/${role.short}.png" 
                                    alt="${role.short}" 
                                    style="width: 100%; height: 100%; object-fit: cover;"
                                    onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=&quot;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#666;color:white;font-size:12px;&quot;>${role.short}</div>'">
                            </div>
                            <div style="flex: 1;">
                                <div class="name">${role.name}</div>
                                <span class="type ${typeClass}">${role.type}</span>
                                <div class="ai">${role.ai}</div>
                            </div>
                        </div>
                    `;
                    if (isDuplicate) {
                        const badge = document.createElement('div');
                        badge.innerHTML = '<i class="fas fa-exclamation-triangle"></i> å·²å­˜åœ¨';
                        badge.style.position = 'absolute';
                        badge.style.top = '8px';
                        badge.style.right = '8px';
                        badge.style.background = 'rgba(255,193,7,0.9)';
                        badge.style.color = '#5d4037';
                        badge.style.padding = '2px 6px';
                        badge.style.borderRadius = '12px';
                        badge.style.fontSize = '10px';
                        badge.style.fontWeight = 'bold';
                        div.appendChild(badge);
                    } else {
                        div.onclick = () => selectRoleImmediate(role);
                    }
                    roleOptions.appendChild(div);
                });

                // ===== æ·»åŠ ã€Œè‡ªå®šä¹‰è§’è‰²ã€å¡ç‰‡ =====
                const customDiv = document.createElement('div');
                customDiv.className = 'role-option';
                customDiv.style.background = '#f9f9f9';
                customDiv.style.border = '2px dashed #1E88E5';
                customDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 40px; height: 40px; border-radius: 6px; background: #e3f2fd; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                            <i class="fas fa-plus" style="color: #1E88E5;"></i>
                        </div>
                        <div style="flex: 1;">
                            <div class="name" style="color: #1E88E5;">è‡ªå®šä¹‰è§’è‰²</div>
                            <span class="type type-support" style="background:#e3f2fd;color:#0d47a1;">ç‚¹å‡»åˆ›å»ºæ–°è§’è‰²</span>
                        </div>
                    </div>
                `;
                customDiv.onclick = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    if (customDiv.dataset.locked) return;
                    customDiv.dataset.locked = '1';
                    setTimeout(() => { customDiv.dataset.locked = ''; }, 300);
                    // âœ… ä¸å† closeRoleSelectï¼é¿å…æ¸… selectedCell
                    openCustomRoleForm();
                };
                roleOptions.appendChild(customDiv);

                overlay.classList.add('active');
            }

            function selectRoleImmediate(role) {
                if (!selectedCell) return;
                const { row, col, side } = selectedCell;
                const order = side === 'red' ? STATE.redOrder : STATE.blueOrder;
                // åŒåŒºåŸŸæ˜¯å¦å·²å­˜åœ¨ç›¸åŒè§’è‰²
                const isDuplicate = order.some(u => u.role.short === role.short);
                if (isDuplicate) {
                    showNotification(`âš ï¸ ${side === 'blue' ? 'æˆ‘æ–¹' : 'æ•Œæ–¹'}é˜µå®¹ä¸­å·²å­˜åœ¨ ${role.name}`, 'warning');
                    return;
                }
                // æ£€æŸ¥æ•°é‡é™åˆ¶
                if (order.length >= 4) {
                    showNotification(`æœ€å¤šå¸ƒç½®4ä¸ª${side === 'red' ? 'æ•Œæ–¹' : 'æˆ‘æ–¹'}è§’è‰²ï¼`, 'warning');
                    return;
                }
                const unit = { side, role, pos: [row, col], index: order.length, isNew: true };
                STATE.map[row][col] = unit;
                order.push(unit);
                closeRoleSelect();
                renderMap();
                showNotification(`âœ… å·²å¸ƒç½® ${role.name}`, 'success');
            }

            function closeRoleSelect() {
                overlay.classList.remove('active');
                selectedCell = null;
                pendingRole = null;
            }

            function removeUnit(r, c) {
                const unit = STATE.map[r][c];
                if (!unit) return;
                const order = unit.side === 'red' ? STATE.redOrder : STATE.blueOrder;
                const idx = order.findIndex(u => u.pos[0] === r && u.pos[1] === c);
                if (idx !== -1) {
                    order.splice(idx, 1);
                    order.forEach((u, i) => u.index = i);
                }
                STATE.map[r][c] = null;
                renderMap();
                showNotification(`å·²ç§»é™¤ ${unit.role.name}`, 'info');
            }

            // ===== é˜µå®¹é¡ºåºæ¸²æŸ“ =====
            function renderOrderLists() {
                renderOrder(STATE.blueOrder, blueOrderEl, 'blue');
                renderOrder(STATE.redOrder, redOrderEl, 'red');
            }

            function renderOrder(list, container, side) {
                container.innerHTML = '';
                list.forEach((unit, i) => {
                    const div = document.createElement('div');
                    div.className = 'role-item';
                    const computedTargets = computeTargets();
                    const lockedUnits = new Set(computedTargets.map(t => t.to));
                    // ä¸ºæœªé”å®šè§’è‰²æ·»åŠ æ ‡è®°
                    if (unit && !lockedUnits.has(unit)) {
                        const marker = document.createElement('div');
                        marker.style.cssText = `
                        position: absolute; top: 4px; right: 4px; 
                        width: 10px; height: 10px; 
                        background: #FF5722; border-radius: 50%; 
                        font-size: 8px; color: white; 
                        display: flex; align-items: center; justify-content: center;
                        font-weight: bold;
                    `;
                        marker.textContent = '!';
                        div.appendChild(marker);
                    }
                    if (i === 0) div.classList.add('highlight');
                    if (unit.isNew) {
                        div.classList.add('new');
                        setTimeout(() => div.classList.remove('new'), 400);
                        delete unit.isNew;
                    }
                    const avatarDiv = document.createElement('div');
                    avatarDiv.className = 'avatar';
                    avatarDiv.style.display = 'flex';
                    avatarDiv.style.alignItems = 'center';
                    avatarDiv.style.justifyContent = 'center';
                    avatarDiv.style.fontSize = '14px';
                    avatarDiv.style.fontWeight = 'bold';
                    const showAvatars = document.getElementById('showAvatars').checked;
                    if (showAvatars) {
                        const img = document.createElement('img');
                        img.src = `./asset/${unit.role.short}.png`;
                        img.alt = unit.role.short;
                        img.style.width = '100%';
                        img.style.height = '100%';
                        img.style.objectFit = 'cover';
                        img.style.borderRadius = '8px';
                        img.onerror = () => {
                            img.style.display = 'none';
                            avatarDiv.textContent = unit.role.short;
                            avatarDiv.style.background = unit.role.color ?
                                `linear-gradient(135deg, ${unit.role.color}80, ${unit.role.color}FF)` :
                                '#666';
                        };
                        avatarDiv.appendChild(img);
                    } else {
                        avatarDiv.textContent = unit.role.short;
                        avatarDiv.style.background = unit.role.color ?
                            `linear-gradient(135deg, ${unit.role.color}80, ${unit.role.color}FF)` :
                            '#666';
                    }
                    div.insertBefore(avatarDiv, div.firstChild);
                    const aiIconMap = {
                        'è¿‘æˆ˜ai':      { icon: 'fist-raised', color: '#2196F3' },
                        'è¿œç¨‹ai':      { icon: 'crosshairs', color: '#4CAF50' },
                        'è¾…åŠ©åˆºå®¢ai':  { icon: 'arrow-turn-up', color: '#FF5722' },
                        'å°„æ‰‹åˆºå®¢ai':  { icon: 'arrow-turn-up', color: '#9C27B0' },
                        'å°±è¿‘åˆºå®¢ai':  { icon: 'arrow-turn-up', color: '#607D8B' }
                    };
                    const aiMeta = aiIconMap[unit.role.ai] || { icon: 'question', color: '#9E9E9E' };
                    const aiMarker = document.createElement('div');
                    aiMarker.style.cssText = `
                        position: absolute;
                        top: 4px;
                        left: 4px;
                        width: 14px;
                        height: 14px;
                        border-radius: 50%;
                        background: white;
                        border: 1px solid ${aiMeta.color};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 8px;
                        color: ${aiMeta.color};
                        box-shadow: 0 1px 2px rgba(0,0,0,0.2);
                        z-index: 3;
                    `;
                    aiMarker.innerHTML = `<i class="fas fa-${aiMeta.icon}" style="font-size:8px;"></i>`;
                    aiMarker.title = unit.role.ai; // hover æç¤º
                    div.appendChild(aiMarker);
                    if (i > 0) {
                        const btn = document.createElement('div');
                        btn.className = 'swap-btn';
                        btn.innerHTML = '<i class="fas fa-exchange-alt"></i>';
                        btn.onclick = (e) => {
                            e.stopPropagation();
                            swapOrder(side, i);
                        };
                        div.appendChild(btn);
                    }
                    container.appendChild(div);
                });
            }

            function swapOrder(side, idx) {
                if (idx <= 0) return;
                const order = side === 'red' ? STATE.redOrder : STATE.blueOrder;
                [order[idx - 1], order[idx]] = [order[idx], order[idx - 1]];
                order.forEach((u, i) => u.index = i);
                renderMap();
                showNotification('é˜µå®¹é¡ºåºå·²è°ƒæ•´', 'success');
            }

            // ===== ç´¢æ•Œé€»è¾‘ & ç®­å¤´ç»˜åˆ¶ =====
            function findTarget(attacker, candidates, isRedAttacker) {
                const { ai } = attacker.role;
                const unhit = candidates.filter(c => !c.isHit);
                let target = null;

                if (ai === 'è¾…åŠ©åˆºå®¢ai' || ai === 'å°„æ‰‹åˆºå®¢ai') {
                    const targetType = ai === 'è¾…åŠ©åˆºå®¢ai' ? 'è¾…åŠ©' : 'å°„æ‰‹';
                    // å…ˆç­›é€‰å‡ºæ‰€æœ‰ã€Œç›®æ ‡ç±»å‹ã€æ•Œäººï¼ˆä¸å‰”é™¤ isHitï¼åˆºå®¢å¯æ— è§†é”å®šåˆ‡äººï¼‰
                    const targetCandidates = candidates.filter(u => u.role.type === targetType);
                    if (targetCandidates.length > 0) {
                        // åœ¨ç›®æ ‡ç±»å‹ä¸­æ‰¾æœ€è¿‘è€…
                        target = findNearest(attacker, targetCandidates);
                    } else {
                        // æ— å¯åˆºç›®æ ‡ â†’ é€€åŒ–ä¸ºæ™®é€šè¿‘æˆ˜é€»è¾‘ï¼šå…¨ä½“æ•Œäººä¸­æ‰¾æœ€è¿‘ï¼ˆä¼˜å…ˆæœªè¢«é”å®šï¼‰
                        const fallbackCandidates = unhit.length > 0 ? unhit : candidates;
                        target = findNearest(attacker, fallbackCandidates);
                    }
                } else if (ai === 'å°±è¿‘åˆºå®¢ai') {
                    const inRange = candidates.filter(u => {
                        const [ar, ac] = attacker.pos;
                        const [br, bc] = u.pos;
                        const distSq = (ar - br) ** 2 + (ac - bc) ** 2;
                        return distSq <= 65;
                    });
                    if (inRange.length > 0) {
                        const unhitInRange = inRange.filter(u => !u.isHit);
                        if (unhitInRange.length > 0) {
                            target = findNearest(attacker, unhitInRange);
                        } else {
                            target = findNearest(attacker, inRange);
                        }
                    } else {
                        target = findNearest(attacker, unhit.length > 0 ? unhit : candidates);
                    }
                } else if (ai === 'è¿‘æˆ˜ai') {
                    target = findNearest(attacker, unhit.length > 0 ? unhit : candidates);
                } else if (ai === 'è¿œç¨‹ai') {
                    target = findNearest(attacker, candidates);
                }
                if (target) target.isHit = true;
                return target;
            }

            function findNearest(unit, candidates) {
                if (candidates.length === 0) return null;
                const [ar, ac] = unit.pos;
                return candidates.reduce((best, u) => {
                    const [br, bc] = u.pos;
                    const d = (ar - br) ** 2 + (ac - bc) ** 2;
                    return d < best.dist ? { unit: u, dist: d } : best;
                }, { unit: null, dist: Infinity }).unit;
            }

            function computeTargets() {
                const originalHitStates = new Map();
                [...STATE.redOrder, ...STATE.blueOrder].forEach(u => {
                    originalHitStates.set(u, u.isHit || false);
                    u.isHit = false;
                });
                const targets = [];
                // é¡ºåºï¼šæˆ‘æ–¹å…¨ä½“ â†’ æ•Œæ–¹å…¨ä½“
                for (const attacker of [...STATE.blueOrder, ...STATE.redOrder]) {
                    const enemyOrder = attacker.side === 'blue' ? STATE.redOrder : STATE.blueOrder;
                    if (enemyOrder.length === 0) continue;

                    const target = findTarget(attacker, enemyOrder, attacker.side === 'red');
                    if (target) {
                        targets.push({ from: attacker, to: target });
                    }
                }
                originalHitStates.forEach((value, unit) => {
                    unit.isHit = value;
                });

                return targets;
            }

            function computeTargetsForState(state) {
                const { blueOrder, redOrder } = state;
                const originalHitStates = new Map();
                [...redOrder, ...blueOrder].forEach(u => {
                    originalHitStates.set(u, u.isHit || false);
                    u.isHit = false;
                });

                const targets = [];
                for (const attacker of [...blueOrder, ...redOrder]) {
                    const enemyOrder = attacker.side === 'blue' ? redOrder : blueOrder;
                    if (enemyOrder.length === 0) continue;
                    const target = findTargetForState(attacker, enemyOrder);
                    if (target) {
                        targets.push({ from: attacker, to: target });
                    }
                }

                originalHitStates.forEach((value, unit) => {
                    unit.isHit = value;
                });
                return targets;
            }

            function findTargetForState(attacker, candidates) {
                const { ai } = attacker.role;
                const unhit = candidates.filter(c => !c.isHit);
                let target = null;
                if (ai === 'è¾…åŠ©åˆºå®¢ai' || ai === 'å°„æ‰‹åˆºå®¢ai') {
                    const targetType = ai === 'è¾…åŠ©åˆºå®¢ai' ? 'è¾…åŠ©' : 'å°„æ‰‹';
                    target = unhit.find(u => u.role.type === targetType);
                    if (!target) target = candidates.find(u => u.role.type === targetType);
                    if (!target) target = findNearestForState(attacker, unhit.length > 0 ? unhit : candidates);
                } else if (ai === 'è¿‘æˆ˜ai') {
                    target = findNearestForState(attacker, unhit.length > 0 ? unhit : candidates);
                } else if (ai === 'è¿œç¨‹ai') {
                    target = findNearestForState(attacker, candidates);
                }
                if (target) target.isHit = true;
                return target;
            }

            function findNearestForState(unit, candidates) {
                if (candidates.length === 0) return null;
                const [ar, ac] = unit.pos;
                return candidates.reduce((best, u) => {
                    const [br, bc] = u.pos;
                    const d = (ar - br) ** 2 + (ac - bc) ** 2;
                    return d < best.dist ? { unit: u, dist: d } : best;
                }, { unit: null, dist: Infinity }).unit;
            }

            function drawArrows() {
                const targets = computeTargets();
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                const arrowLayerRect = arrowLayer.getBoundingClientRect();
                svg.setAttribute("width", "100%");
                svg.setAttribute("height", "100%");
                svg.setAttribute("viewBox", `0 0 ${arrowLayerRect.width} ${arrowLayerRect.height}`);
                // ===== åˆ›å»º marker =====
                const defs = document.createElementNS(svgNS, "defs");
                const createMarker = (id, color) => {
                    const marker = document.createElementNS(svgNS, "marker");
                    marker.setAttribute("id", id);
                    marker.setAttribute("markerWidth", "8");
                    marker.setAttribute("markerHeight", "6");
                    marker.setAttribute("refX", "7");
                    marker.setAttribute("refY", "3");
                    marker.setAttribute("orient", "auto");
                    const poly = document.createElementNS(svgNS, "polygon");
                    poly.setAttribute("points", "0 0, 8 3, 0 6");
                    poly.setAttribute("fill", color);
                    marker.appendChild(poly);
                    return marker;
                };
                const blueMarker = createMarker("blueArrow", "#1E88E5");
                const redMarker = createMarker("redArrow", "#E53935");
                const dualMarkerStart = createMarker("dualStart", "#7B1FA2");
                const dualMarkerEnd = createMarker("dualEnd", "#7B1FA2");
                dualMarkerStart.setAttribute("orient", "auto-start-reverse");
                defs.append(blueMarker, redMarker, dualMarkerStart, dualMarkerEnd);
                svg.appendChild(defs);
                // ===== åŒå‘æ£€æµ‹ =====
                const showDualArrows = document.getElementById('showDualArrows').checked;
                const dualPairs = new Set();
                const processed = new Set();
                if (showDualArrows) {
                    for (let i = 0; i < targets.length; i++) {
                        const t1 = targets[i];
                        if (t1.from.side === t1.to.side) continue;
                        for (let j = i + 1; j < targets.length; j++) {
                            const t2 = targets[j];
                            if (t2.from.side === t2.to.side) continue;
                            if (t1.from === t2.to && t1.to === t2.from) {
                                const isBlueRedPair =
                                    (t1.from.side === 'blue' && t1.to.side === 'red') ||
                                    (t1.from.side === 'red' && t1.to.side === 'blue');
                                if (isBlueRedPair) {
                                    const key = `${t1.from.side}-${t1.from.pos.join('-')}|${t1.to.side}-${t1.to.pos.join('-')}`;
                                    dualPairs.add(key);
                                    processed.add(i);
                                    processed.add(j);
                                    break;
                                }
                            }
                        }
                    }
                }
                const getCenter = (r, c) => {
                    const cell = mapEl.children[r * 14 + c];
                    if (!cell) return { x: 0, y: 0 };
                    const cellRect = cell.getBoundingClientRect();
                    const layerRect = arrowLayer.getBoundingClientRect();
                    return {
                        x: cellRect.left + cellRect.width / 2 - layerRect.left,
                        y: cellRect.top + cellRect.height / 2 - layerRect.top
                    };
                };
                // ===== ç»˜åˆ¶å•å‘ç®­å¤´ =====
                targets.forEach((target, idx) => {
                    if (processed.has(idx) && showDualArrows) return;
                    const { from, to } = target;
                    const start = getCenter(...from.pos);
                    const end = getCenter(...to.pos);
                    const seed = from.pos[0] * 1e3 + from.pos[1] * 1e2 + to.pos[0] * 10 + to.pos[1];
                    const offset = ((seed * 9301 + 49297) % 71 - 35) * 0.3;
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const len = Math.hypot(dx, dy) || 1;
                    const nx = -dy / len;
                    const ny = dx / len;
                    const path = document.createElementNS(svgNS, "path");
                    path.setAttribute("d", `M ${start.x + nx * offset} ${start.y + ny * offset} L ${end.x + nx * offset} ${end.y + ny * offset}`);
                    path.setAttribute("fill", "none");
                    path.setAttribute("stroke", from.side === 'blue' ? "#1E88E5" : "#E53935");
                    path.setAttribute("stroke-width", "2.5");
                    path.setAttribute("stroke-linecap", "round");
                    path.setAttribute("marker-end", from.side === 'blue' ? "url(#blueArrow)" : "url(#redArrow)");
                    svg.appendChild(path);
                });
                // ===== ç»˜åˆ¶åŒå‘ç®­å¤´ =====
                dualPairs.forEach(key => {
                    const [fromKey, toKey] = key.split('|');
                    const [, fr, fc] = fromKey.split('-').map(Number);
                    const [, tr, tc] = toKey.split('-').map(Number);
                    const start = getCenter(fr, fc);
                    const end = getCenter(tr, tc);
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const len = Math.hypot(dx, dy) || 1;
                    const nx = -dy / len;
                    const ny = dx / len;
                    const offset = 6;
                    const path = document.createElementNS(svgNS, "path");
                    path.setAttribute("d", `M ${start.x + nx * offset} ${start.y + ny * offset} L ${end.x - nx * offset} ${end.y - ny * offset}`);
                    path.setAttribute("fill", "none");
                    path.setAttribute("stroke", "#7B1FA2");
                    path.setAttribute("stroke-width", "3");
                    path.setAttribute("stroke-linecap", "round");
                    path.setAttribute("marker-start", "url(#dualStart)");
                    path.setAttribute("marker-end", "url(#dualEnd)");
                    svg.appendChild(path);
                });
                arrowLayer.innerHTML = '';
                arrowLayer.appendChild(svg);
            }

            function openCustomRoleForm() {
                const formHtml = `
                    <div class="role-select" style="max-width: 400px;">
                        <div class="modal-header" style="background: linear-gradient(90deg, #6a11cb, #2575fc);">
                            <h3><i class="fas fa-user-edit"></i> è‡ªå®šä¹‰è§’è‰²</h3>
                        </div>
                        <div class="modal-body" style="padding: 20px;">
                            <div style="margin-bottom: 14px;">
                                <label style="display:block; margin-bottom:4px; font-weight:500;">è§’è‰²å</label>
                                <input type="text" id="customName" placeholder="ä¾‹å¦‚ï¼šå“ˆå¨œ" style="width:100%; padding:8px; border:1px solid #ccc; border-radius:6px;" autofocus>
                            </div>
                            <div style="margin-bottom: 14px;">
                                <label style="display:block; margin-bottom:4px; font-weight:500;">ç±»å‹</label>
                                <select id="customType" style="width:100%; padding:8px; border:1px solid #ccc; border-radius:6px;">
                                    <option value="æˆ˜å£«">æˆ˜å£«</option>
                                    <option value="å¦å…‹">å¦å…‹</option>
                                    <option value="è¾…åŠ©">è¾…åŠ©</option>
                                    <option value="å°„æ‰‹">å°„æ‰‹</option>
                                </select>
                            </div>
                            <div style="margin-bottom: 14px;">
                                <label style="display:block; margin-bottom:4px; font-weight:500;">AI ç±»å‹</label>
                                <select id="customAI" style="width:100%; padding:8px; border:1px solid #ccc; border-radius:6px;">
                                    <option value="è¿‘æˆ˜ai">è¿‘æˆ˜ai</option>
                                    <option value="è¿œç¨‹ai">è¿œç¨‹ai</option>
                                    <option value="è¾…åŠ©åˆºå®¢ai">è¾…åŠ©åˆºå®¢ai</option>
                                    <option value="å°„æ‰‹åˆºå®¢ai">å°„æ‰‹åˆºå®¢ai</option>
                                    <option value="å°±è¿‘åˆºå®¢ai">å°±è¿‘åˆºå®¢ai</option>
                                </select>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-cancel" onclick="closeCustomForm()">å–æ¶ˆ</button>
                            <button class="btn btn-confirm" onclick="submitCustomRole()">åˆ›å»ºå¹¶ç½®å…¥</button>
                        </div>
                    </div>
                `;
                overlay.innerHTML = formHtml;
                overlay.classList.add('active');
            }

            function closeCustomForm() {
                overlay.classList.remove('active');
            }

            function submitCustomRole() {
                const name = document.getElementById('customName')?.value.trim();
                const type = document.getElementById('customType')?.value;
                const ai = document.getElementById('customAI')?.value;
                if (!name) {
                    showNotification('âš ï¸ è§’è‰²åä¸èƒ½ä¸ºç©ºï¼', 'warning');
                    return;
                }
                const short = name;
                const color = '#9E9E9E';
                const customRole = { 
                    name, type, ai, short, color,
                    speed: 1.0,
                    reach: 0.2,
                    skillRange: -1,
                    skillCastTime: 0.0,
                    skillDashSpeed: 0.0,
                    skillDashDist: 0.0,
                    tauntRadius: 0,
                    resistA: 1, resistB: 2, resistC: 100,
                };
                if (selectedCell) {
                    const { row, col, side } = selectedCell;
                    const order = side === 'red' ? STATE.redOrder : STATE.blueOrder;
                    if (order.length >= 4) {
                        showNotification(`æœ€å¤šå¸ƒç½®4ä¸ª${side === 'red' ? 'æ•Œæ–¹' : 'æˆ‘æ–¹'}è§’è‰²ï¼`, 'warning');
                        return;
                    }
                    if (order.some(u => u.role.short === short)) {
                        showNotification(`âš ï¸ ${side === 'blue' ? 'æˆ‘æ–¹' : 'æ•Œæ–¹'}é˜µå®¹ä¸­å·²å­˜åœ¨åŒç¼©å†™è§’è‰²`, 'warning');
                        return;
                    }
                    const unit = { side, role: customRole, pos: [row, col], index: order.length, isNew: true };
                    STATE.map[row][col] = unit;
                    order.push(unit);
                    overlay.classList.remove('active');
                    renderMap();
                    showNotification(`âœ… å·²åˆ›å»ºå¹¶å¸ƒç½®è‡ªå®šä¹‰è§’è‰² "${name}"`, 'success');
                } else {
                    ALL_ROLES.push(customRole);
                    overlay.classList.remove('active');
                    showNotification(`âœ… è‡ªå®šä¹‰è§’è‰² "${name}" å·²ä¿å­˜`, 'success');
                }
            }

            // ===== é€šçŸ¥ç³»ç»Ÿ =====
            function showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 500;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                    z-index: 10000;
                    transform: translateX(200%);
                    transition: transform 0.3s ease;
                `;
                let bgColor = '#2196F3';
                if (type === 'success') bgColor = '#4CAF50';
                else if (type === 'warning') bgColor = '#FF9800';
                else if (type === 'error') bgColor = '#F44336';
                else if (type === 'info') bgColor = '#2196F3';
                notification.style.background = `linear-gradient(90deg, ${bgColor}, ${darkenColor(bgColor, 20)})`;
                notification.textContent = message;
                document.body.appendChild(notification);
                setTimeout(() => {
                    notification.style.transform = 'translateX(0)';
                }, 10);
                setTimeout(() => {
                    notification.style.transform = 'translateX(200%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            function darkenColor(color, percent) {
                let r, g, b;
                if (color.startsWith('#')) {
                    color = color.slice(1);
                    r = parseInt(color.substring(0, 2), 16);
                    g = parseInt(color.substring(2, 4), 16);
                    b = parseInt(color.substring(4, 6), 16);
                } else {
                    return color;
                }
                r = Math.max(0, r * (1 - percent / 100));
                g = Math.max(0, g * (1 - percent / 100));
                b = Math.max(0, b * (1 - percent / 100));
                return `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
            }

            initMap();
            ALL_ROLES.forEach(role => {
                if (role.speed === undefined) {
                    role.speed = 1.0;
                    role.reach = 0.2;
                    role.skillRange = -1;
                    role.skillCastTime = 0.0;
                    role.skillDashSpeed = 0.0;
                    role.skillDashDist = 0.0;
                    role.tauntRadius = 0;
                    role.resistA = 1; role.resistB = 2; role.resistC = 100;
                }
            });

            let simState = null;
            let simInterval = null;

            let currentSimulation = null;
            let animationFrameId = null;

            function enterSimulationMode() {
                const mask = document.getElementById('simDimMask');
                if (mask) mask.style.opacity = '1';
                // æ·¡å‡ºç¼–è¾‘é¢æ¿ï¼ˆå¯é€‰å¢å¼ºï¼‰
                document.querySelectorAll('.order-panel').forEach(el => {
                    el.style.opacity = '0.25';
                    el.style.pointerEvents = 'none';
                });
            }

            function exitSimulationMode() {
                const mask = document.getElementById('simDimMask');
                if (mask) mask.style.opacity = '0';
                document.querySelectorAll('.order-panel').forEach(el => {
                    el.style.opacity = '';
                    el.style.pointerEvents = '';
                });
            }
            function startSimulation() {
                // âœ… 1. è¿›å…¥æ¨¡æ‹Ÿæ¨¡å¼ï¼šéšè—ç¼–è¾‘ UI
                enterSimulationMode();

                // âœ… 2. åˆå§‹åŒ–æ¨¡æ‹ŸçŠ¶æ€
                currentSimulation = initSimulation();

                // âœ… 3. æ¸²æŸ“é¦–å¸§
                renderSimulation(currentSimulation);

                // âœ… 4. å¯åŠ¨çœŸå®æ—¶é—´åŠ¨ç”»å¾ªç¯
                let lastTime = performance.now();
                function animate(now) {
                    if (!currentSimulation.isRunning) {
                        // æ¨¡æ‹Ÿè‡ªç„¶ç»“æŸ â†’ æ˜¾ç¤ºé‡æ’­æŒ‰é’®
                        document.getElementById('btnStopSimulate').style.display = 'none';
                        document.getElementById('btnReplaySimulate').style.display = 'inline-block';
                        return;
                    }

                    const dt = Math.min((now - lastTime) / 1000, 0.01); // ç§’ï¼Œä¸Šé™ 100ms é˜²è·³å¸§
                    lastTime = now;

                    tick(currentSimulation, dt);
                    renderSimulation(currentSimulation);

                    animationFrameId = requestAnimationFrame(animate);
                }

                // é¦–å¸§ç«‹å³å¯åŠ¨ï¼Œé¿å…é¦–å¸§ç©ºè·‘
                animationFrameId = requestAnimationFrame((now) => {
                    lastTime = now;
                    requestAnimationFrame(animate);
                });

                // âœ… 5. æ›´æ–°æŒ‰é’®çŠ¶æ€
                document.getElementById('btnSimulate').style.display = 'none';
                document.getElementById('btnStopSimulate').style.display = 'inline-block';
                document.getElementById('btnReplaySimulate').style.display = 'none';
            }

            function stopSimulation() {
                // âœ… 1. å–æ¶ˆåŠ¨ç”»
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }

                // âœ… 2. é€€å‡ºæ¨¡æ‹Ÿæ¨¡å¼ï¼šæ¢å¤ç¼–è¾‘ UI
                exitSimulationMode();

                // âœ… 3. æ¸…ç©ºå¯è§†åŒ–å±‚
                const overlay = document.getElementById('simOverlay');
                if (overlay) overlay.innerHTML = '';

                // âœ… 4. æ¢å¤æŒ‰é’®
                document.getElementById('btnSimulate').style.display = 'inline-block';
                document.getElementById('btnStopSimulate').style.display = 'none';
                document.getElementById('btnReplaySimulate').style.display = 'none';

                currentSimulation = null;
            }

            function replaySimulation() {
                stopSimulation(); // å…ˆæ¸…ç†
                setTimeout(startSimulation, 100); // å†å¯åŠ¨ï¼ˆé¿å…çŠ¶æ€æ®‹ç•™ï¼‰
            }

            // âœ… ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.getElementById('btnSimulate').onclick = startSimulation;
            document.getElementById('btnStopSimulate').onclick = stopSimulation;
            document.getElementById('btnReplaySimulate').onclick = replaySimulation;

            // âœ… ESC é”®å¿«é€Ÿé€€å‡ºæ¨¡æ‹Ÿ
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && currentSimulation) {
                    stopSimulation();
                }
            });




            setTimeout(() => {
                // æ­¤å¤„å¯ä»¥å¸ƒç½®ä¸€äº›åˆå§‹è§’è‰²
                const examples = [];
                examples.forEach(ex => {
                    const unit = { side: ex.side, role: ex.role, pos: [ex.r, ex.c], index: 0, isNew: true };
                    STATE.map[ex.r][ex.c] = unit;
                    if (ex.side === 'blue') STATE.blueOrder.push(unit);
                    else STATE.redOrder.push(unit);
                });
                // æ›´æ–°ç´¢å¼•
                STATE.blueOrder.forEach((u, i) => u.index = i);
                STATE.redOrder.forEach((u, i) => u.index = i);

                renderMap();
            }, 500);

            document.getElementById('showAvatars').addEventListener('change', () => {
                renderMap();
            });

            let dragState = {
                isActive: false,
                isClickPrevented: false,
                isScrolling: false,
                touchStartX: 0,
                touchStartY: 0,
                startRow: -1,
                startCol: -1,
                currentRow: -1,
                currentCol: -1,
                draggedUnit: null,
                validDropZone: null
            };

            function handleDragStart(e, r, c) {
                setTimeout(() => {
                    if (!dragState.isClickPrevented) {
                        const unit = STATE.map[r][c];
                        if (!unit) return;

                        dragState = {
                            isActive: true,
                            isClickPrevented: true,
                            startRow: r,
                            startCol: c,
                            currentRow: r,
                            currentCol: c,
                            draggedUnit: unit,
                            validDropZone: unit.side === 'blue' ?
                                { min: 0, max: 3 } : { min: 10, max: 13 }
                        };

                        createDragPreview(e, unit);
                    }
                }, 150);
            }

            function createDragPreview(e, unit) {
                const preview = document.createElement('div');
                preview.id = 'drag-preview';
                preview.style.cssText = `
                    position: fixed;
                    width: 46px;
                    height: 46px;
                    background: ${unit.side === 'blue' ? 'rgba(30, 136, 229, 0.8)' : 'rgba(229, 57, 53, 0.8)'};
                    border-radius: 6px;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                    font-size: 10px;
                    z-index: 10000;
                    pointer-events: none;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                // æ·»åŠ å¤´åƒ/ç¼©å†™
                const showAvatars = document.getElementById('showAvatars')?.checked ?? true;
                if (showAvatars) {
                    const img = document.createElement('img');
                    img.src = `./asset/${unit.role.short}.png`;
                    img.alt = unit.role.short;
                    img.style.width = '20px';
                    img.style.height = '20px';
                    img.style.objectFit = 'cover';
                    img.style.marginBottom = '2px';
                    img.onerror = () => preview.innerHTML = unit.role.short;
                    preview.appendChild(img);
                } else {
                    preview.textContent = unit.role.short;
                }
                preview.setAttribute('draggable', 'false');
                document.body.appendChild(preview);
                preview.addEventListener('dragstart', e => e.preventDefault());
                updateDragPreviewPosition(e);
            }

            function updateDragPreviewPosition(e) {
                const preview = document.getElementById('drag-preview');
                if (!preview) return;
                preview.style.left = (e.clientX - 23) + 'px';
                preview.style.top = (e.clientY - 23) + 'px';
            }

            function handleDragMove(e) {
                if (!dragState.isActive) return;
                updateDragPreviewPosition(e);
                const mapRect = mapEl.getBoundingClientRect();
                const cellSize = 46;
                const gap = 4;
                const relX = e.clientX - mapRect.left - 12;
                const relY = e.clientY - mapRect.top - 12;
                const col = Math.floor(relX / (cellSize + gap));
                const row = Math.floor(relY / (cellSize + gap));
                if (row >= 0 && row < 5 &&
                    col >= dragState.validDropZone.min && col <= dragState.validDropZone.max) {
                    dragState.currentRow = row;
                    dragState.currentCol = col;
                    highlightTargetCell(row, col);
                } else {
                    clearTargetHighlight();
                }
            }

            function highlightTargetCell(row, col) {
                clearTargetHighlight();
                const targetCell = mapEl.children[row * 14 + col];
                if (!targetCell) return;
                targetCell.style.outline = '3px dashed ' + (dragState.draggedUnit.side === 'blue' ? '#1E88E5' : '#E53935');
                targetCell.style.outlineOffset = '2px';
                targetCell.dataset.isTarget = 'true';
            }

            function clearTargetHighlight() {
                document.querySelectorAll('.cell[data-is-target="true"]').forEach(cell => {
                    cell.style.outline = '';
                    cell.style.outlineOffset = '';
                    cell.dataset.isTarget = '';
                });
            }

            function handleDragEnd() {
                if (!dragState.isActive) return;
                // ç§»é™¤é¢„è§ˆ
                const preview = document.getElementById('drag-preview');
                if (preview) preview.remove();
                // æ¸…é™¤é«˜äº®
                clearTargetHighlight();
                const { startRow, startCol, currentRow, currentCol, draggedUnit } = dragState;
                // æ£€æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆä½ç½®é‡Šæ”¾
                if (currentRow >= 0 && currentRow < 5 &&
                    currentCol >= dragState.validDropZone.min && currentCol <= dragState.validDropZone.max) {
                    if (startRow !== currentRow || startCol !== currentCol) {
                        const targetUnit = STATE.map[currentRow][currentCol];
                        if (!targetUnit) {
                            // ç§»åŠ¨åˆ°ç©ºæ ¼
                            STATE.map[startRow][startCol] = null;
                            STATE.map[currentRow][currentCol] = draggedUnit;
                            draggedUnit.pos = [currentRow, currentCol];
                            showNotification(`ç§»åŠ¨ ${draggedUnit.role.name} åˆ° (${currentRow + 1},${currentCol + 1})`, 'success');
                        } else if (targetUnit.side === draggedUnit.side) {
                            // åŒé˜µè¥äº¤æ¢
                            STATE.map[startRow][startCol] = targetUnit;
                            STATE.map[currentRow][currentCol] = draggedUnit;
                            draggedUnit.pos = [currentRow, currentCol];
                            targetUnit.pos = [startRow, startCol];
                            showNotification(`äº¤æ¢ ${draggedUnit.role.name} ä¸ ${targetUnit.role.name}`, 'success');
                        }
                        renderMap();
                    } else {
                        removeUnit(startRow, startCol);
                        renderMap();
                    }
                }
                dragState = {
                    isActive: false,
                    isClickPrevented: false,
                    lastDragEndTime: Date.now(),
                    startRow: -1,
                    startCol: -1,
                    currentRow: -1,
                    currentCol: -1,
                    draggedUnit: null,
                    validDropZone: null
                };
            }

            document.addEventListener('DOMContentLoaded', () => {
                const originalRenderMap = window.renderMap;
                window.renderMap = function () {
                    originalRenderMap();
                    checkAllRules();
                };
            });

            document.getElementById('showDualArrows').addEventListener('change', () => {
                drawArrows();
            });

            window.STATE = STATE;
            window.computeTargets = computeTargets;
        
        </script>
</body>

</html>