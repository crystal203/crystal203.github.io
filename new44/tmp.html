<script>
    function getUnitByShort(side, short, orderList = null) {
        const order = orderList || (side === 'blue' ? STATE.blueOrder : STATE.redOrder);
        return order.find(u => u.role.short === short);
    }

    function getPos(unit) { return unit ? unit.pos : null; }
    function getX(unit) { return getPos(unit)?.[1] ?? -1; }
    function getY(unit) { return getPos(unit)?.[0] ?? -1; }
    function resolveChar(expr) {
        const m1 = expr.match(/^([BR])\-([A-Za-z]+)$/);
        const m2 = expr.match(/^([BR])\-([A-Za-z]+)\-lock$/);
        if (m1) {
            const [_, sideChar, short] = m1;
            return getUnitByShort(sideChar === 'B' ? 'blue' : 'red', short);
        } else if (m2) {
            const [_, sideChar, short] = m2;
            const unit = getUnitByShort(sideChar === 'B' ? 'blue' : 'red', short);
            if (!unit) return null;
            // éœ€è°ƒç”¨ computeTargets() è·å–å…¶é”å®šç›®æ ‡
            const targets = computeTargets(); // â† ä½ ç°æœ‰å‡½æ•°ï¼ˆæ³¨æ„ï¼šéœ€æš´éœ²ä¸ºå…¨å±€æˆ–ä¼ å…¥ï¼‰
            const target = targets.find(t => t.from === unit)?.to;
            return target;
        }
        return null;
    }
    const REL = {
        equ: (a, b) => a === b,
        neq: (a, b) => a !== b,
        ge: (a, b) => a >= b,
        le: (a, b) => a <= b,
    };

    // === è§„åˆ™è¯„ä¼°ä¸»å‡½æ•° ===
    function evaluateRule(rule) {
        const { blueOrder, redOrder } = STATE;

        // === Step 1ï¼šé˜Ÿä¼åŒ¹é… ===
        const checkTeamMatch = (sideOrder, targetList) => {
            if (sideOrder.length !== 4) return false;
            if (sideOrder[0]?.role.short !== targetList[0]) return false;
            const actualSet = new Set(sideOrder.map(u => u.role.short));
            const targetSet = new Set(targetList);
            return actualSet.size === 4 && [...actualSet].sort().join() === [...targetSet].sort().join();
        };
        const pre = rule.preconditions;
        if (!checkTeamMatch(redOrder, pre.team.red)) {
            return {
                redMatched: false,
                blueMatched: false
            };
        }
        // === Step 2ï¼šçº¢æ–¹ä½ç½®å‰æ ===
        for (let [short, axis, rel, val] of pre.redPosition) {
            const unit = getUnitByShort('red', short);
            if (!unit) return { matched: false };
            const posVal = axis === 'x-pos' ? getX(unit) : getY(unit);
            if (!REL[rel](posVal, val))
                return {
                    redMatched: false,
                    blueMatched: false
                }
        }

        if (!checkTeamMatch(blueOrder, pre.team.blue)) {
            return {
                redMatched: true,
                blueMatched: false,
                recommendedBlueTeam: rule.preconditions.team.blue || null,   // ['Eunha', 'Estel', ...]
                tacticName: rule.name,
                tacticDesc: rule.desc || ''
            }
        }

        let bluePositionSatisfied = true;
        if (rule.bluePosition && rule.bluePosition.length > 0) {
            for (let [short, axis, rel, val] of rule.bluePosition) {
                const unit = getUnitByShort('blue', short);
                if (!unit) {
                    bluePositionSatisfied = false;
                    break;
                }
                const posVal = axis === 'x-pos' ? getX(unit) : getY(unit);
                if (!REL[rel](posVal, val)) {
                    bluePositionSatisfied = false;
                    break;
                }
            }
        }

        // === Step 4ï¼šè¯„åˆ†è®¡ç®—ï¼ˆè‹¥è“æ–¹ä½ç½®æœªæ»¡è¶³ï¼Œscore å¼ºåˆ¶ä¸º 0ï¼‰===
        let score = 0;
        const matchedScorings = [];

        // ã€å…³é”®æ”¹åŠ¨ã€‘å…ˆæ ‡è®°æ˜¯å¦é€šè¿‡è“æ–¹å‰ç½®ï¼ˆä»…å½±å“åˆ†æ•°ï¼Œä¸é˜»æ–­ matchedï¼‰
        const passedBluePosition = bluePositionSatisfied;

        // è®¡ç®—åŸå§‹åˆ†ï¼ˆä»ç´¯åŠ ï¼Œç”¨äºæ˜¾ç¤ºæ˜ç»†ï¼‰
        for (const item of rule.scoring) {
            let ok = false;
            try {
                if (item.length === 5) {
                    const [expr, axis, rel, val, pts] = item;
                    const unit = resolveChar(expr);
                    if (unit) {
                        const posVal = axis === 'x-pos' ? getX(unit) : getY(unit);
                        if (REL[rel](posVal, val)) {
                            ok = true; score += pts;
                        }
                    }
                } else if (item.length === 7 && item[3] === 'delta') {
                    const [e1, e2, axis, _, rel, val, pts] = item;
                    const u1 = resolveChar(e1), u2 = resolveChar(e2);
                    if (u1 && u2) {
                        const p1 = axis === 'x-pos' ? getX(u1) : getY(u1);
                        const p2 = axis === 'x-pos' ? getX(u2) : getY(u2);
                        if (REL[rel](Math.abs(p1 - p2), val)) {
                            ok = true; score += pts;
                        }
                    }
                } else if (item.length === 4 && item[1] === 'lock') {
                    const [fromExpr, , toExpr, pts] = item;
                    const fromUnit = resolveChar(fromExpr);
                    const toUnit = resolveChar(toExpr);
                    if (fromUnit && toUnit) {
                        const targets = computeTargets();
                        const target = targets.find(t => t.from === fromUnit)?.to;
                        if (target === toUnit) {
                            ok = true; score += pts;
                        }
                    }
                }
            } catch (e) {
                console.warn(`è¯„åˆ†é¡¹è§£æå¤±è´¥:`, item, e);
            }
            if (ok) matchedScorings.push(item);
        }

        // ã€å¼ºåˆ¶é€»è¾‘ã€‘ï¼šè‹¥è“æ–¹ä½ç½®ä¸æ»¡è¶³ â†’ æœ€ç»ˆå¾—åˆ† = 0ï¼ˆä½†ä¿ç•™åŸå§‹ matchedScorings ä¾›å±•ç¤ºï¼‰
        if (!passedBluePosition) {
            score = 0;
        }

        return {
            redMatched: true,
            blueMatched: true,
            score,
            maxScore: rule.maxScore !== undefined ? rule.maxScore : rule.scoring.reduce((s, it) => s + (it[it.length - 1] || 0), 0),
            matchedScorings,
            bluePositionSatisfied: passedBluePosition,
            // ===== æ–°å¢æ¨èå­—æ®µ =====
            recommendedBlueTeam: rule.preconditions.team.blue || null,   // ['Eunha', 'Estel', ...]
            tacticName: rule.name,
            tacticDesc: rule.desc || ''
        };
    }

    // === æ‰¹é‡æ£€æŸ¥æ‰€æœ‰è§„åˆ™ ===
    async function checkAllRules() {
        const scorePanel = document.getElementById('scorePanel');
        const scoreContent = document.getElementById('scoreContent');
        let allResults = [];

        const rulePaths = [
            './rule/æš—åˆ€ç«é¾™è§£ç«é¾™ä¸‰åˆ‡.js',
            './rule/èå†°ç«é¾™è§£ç«é¾™ä¸‰åˆ‡.js',
            // å¯æ‰©å±•
        ];

        for (let url of rulePaths) {
            try {
                const module = await import(url + '?t=' + Date.now());
                const rule = module.default;
                const result = evaluateRule(rule);
                if (result.redMatched) allResults.push({ rule, result });
            } catch (e) {
                console.warn(`è§„åˆ™ ${url} åŠ è½½å¤±è´¥:`, e.message);
            }
        }

        // æ¸²æŸ“æ™ºèƒ½æˆ˜æœ¯é¢æ¿ï¼ˆä»…æ˜¾ç¤ºæ¨èé˜Ÿä¼ï¼Œä¸ä¾èµ–è“æ–¹å½“å‰çŠ¶æ€ï¼‰
        if (allResults.length === 0) {
            tacticPanel.style.display = 'none';
        } else {
            tacticPanel.style.display = 'block';
            let html = '';

            allResults.forEach(({ rule, result }) => {
                if (!result.recommendedBlueTeam) return; // ä»…æ˜¾ç¤ºæœ‰æ¨èçš„
                const teamNames = result.recommendedBlueTeam.map(short => {
                    const role = ALL_ROLES.find(r => r.short === short);
                    return role ? role.name : short;
                }).join('ã€');

                html += `
            <div style="margin-bottom: 16px; padding: 14px; border: 1px solid #eee; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                    <div>
                        <div style="font-weight: 600; color: #1E88E5; font-size: 1.1rem;">${result.tacticName}</div>
                        <div style="font-size: 0.9rem; color: #666; margin-top: 4px;">${result.tacticDesc || ''}</div>
                    </div>
                    <button 
                        class="btn btn-confirm"
                        onclick="applyTactic(['${result.recommendedBlueTeam.join("','")}'])"
                        style="padding: 6px 16px; font-size: 0.9rem;"
                    >
                        <i class="fas fa-bolt"></i> ä¸€é”®é…ç½®
                    </button>
                </div>
                <div style="font-size: 0.95rem;">
                    æ¨èæˆ‘æ–¹ï¼š${teamNames}
                </div>
            </div>
            `;
            });

            tacticContent.innerHTML = html || '<div style="text-align:center; color:#999; padding:20px;">æš‚æ— æˆ˜æœ¯æ¨è</div>';
        }

        // æ¸²æŸ“è¯„åˆ†é¢æ¿
        if (allResults.length === 0) {
            scorePanel.style.display = 'none';
            return;
        }

        scorePanel.style.display = 'block';
        let html = '';

        allResults.forEach(({ rule, result }) => {
            if (result.blueMatched === true) {
                const pct = (result.score / result.maxScore * 100).toFixed(1);
                const color = pct >= 80 ? '#4CAF50' : pct >= 60 ? '#FF9800' : '#F44336';

                html += `
        <div style="margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #eee;">
          <div style="font-weight: 600; color: #333; margin-bottom: 6px;">
            ğŸ¯ ${rule.name}
          </div>
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <div style="
              width: 100%; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden;
            ">
              <div style="
                height: 100%; background: ${color}; width: ${pct}%; border-radius: 3px;
              "></div>
            </div>
            <span style="font-weight: bold; color: ${color}; min-width: 50px; text-align: right;">
              ${result.score}/${result.maxScore}
            </span>
          </div>
          <div style="font-size: 12px; color: #666;">
            ${rule.desc || ''}
          </div>
        </div>
      `;
            }

        });

        scoreContent.innerHTML = html;
    }

    function applyTactic(shortList) {
        // 1. æ¸…ç©ºç°æœ‰è“æ–¹
        STATE.blueOrder.forEach(u => {
            const [r, c] = u.pos;
            STATE.map[r][c] = null;
        });
        STATE.blueOrder = [];

        // 2. æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨ & å»é‡
        const validRoles = [];
        const seen = new Set();
        for (const short of shortList) {
            if (seen.has(short)) continue;
            const role = ALL_ROLES.find(r => r.short === short);
            if (role) {
                validRoles.push({ role, short });
                seen.add(short);
            }
        }

        if (validRoles.length === 0) {
            showNotification('âš ï¸ æ— æœ‰æ•ˆè§’è‰²å¯é…ç½®', 'warning');
            renderMap();
            return;
        }

        // 3. ä¸€å­—æ’å¼€ï¼šè“åŒºå‰4åˆ—ï¼ˆc=0~3ï¼‰ï¼Œä»ä¸Šåˆ°ä¸‹ r=0,1,2,3,4 å¾ªç¯
        const cols = [0, 1, 2, 3]; // è“åŒºåˆ—
        const rows = [0, 1, 2, 3, 4];
        let placed = 0;

        for (let i = 0; i < validRoles.length && placed < 4; i++) {
            const c = cols[i % 4];
            const r = rows[Math.floor(i / 4) % 5];
            const { role } = validRoles[i];

            // è·³è¿‡å·²è¢«å ç”¨çš„æ ¼å­ï¼ˆæå°æ¦‚ç‡ï¼‰
            let found = false;
            for (let dr = 0; dr < 5 && !found; dr++) {
                const nr = (r + dr) % 5;
                if (!STATE.map[nr][c]) {
                    const unit = { side: 'blue', role, pos: [nr, c], index: placed, isNew: true };
                    STATE.map[nr][c] = unit;
                    STATE.blueOrder.push(unit);
                    placed++;
                    found = true;
                }
            }
        }

        // 4. æ›´æ–°ç´¢å¼• & æ¸²æŸ“
        STATE.blueOrder.forEach((u, i) => u.index = i);
        renderMap();
        showNotification(`âœ… å·²é…ç½®æˆ˜æœ¯é˜µå®¹ï¼š${validRoles.map(v => v.role.name).join('ã€')}`, 'success');
    }

    // æš´éœ²ç»™å…¨å±€
    window.evaluateRule = evaluateRule;
    window.checkAllRules = checkAllRules;
    window.applyTactic = applyTactic;
</script>