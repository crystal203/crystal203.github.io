function getUnitByShort(side, short, orderList = null) {
    const order = orderList || (side === 'blue' ? STATE.blueOrder : STATE.redOrder);
    return order.find(u => u.role.short === short);
}

function getPos(unit) { return unit ? unit.pos : null; }
function getX(unit) { return getPos(unit)?.[1] ?? -1; }
function getY(unit) { return getPos(unit)?.[0] ?? -1; }
function resolveChar(expr) {
    const m1 = expr.match(/^([BR])\-([A-Za-z]+)$/);
    const m2 = expr.match(/^([BR])\-([A-Za-z]+)\-lock$/);
    if (m1) {
        const [_, sideChar, short] = m1;
        return getUnitByShort(sideChar === 'B' ? 'blue' : 'red', short);
    } else if (m2) {
        const [_, sideChar, short] = m2;
        const unit = getUnitByShort(sideChar === 'B' ? 'blue' : 'red', short);
        if (!unit) return null;
        // éœ€è°ƒç”¨ computeTargets() è·å–å…¶é”å®šç›®æ ‡
        const targets = computeTargets(); // â† ä½ ç°æœ‰å‡½æ•°ï¼ˆæ³¨æ„ï¼šéœ€æš´éœ²ä¸ºå…¨å±€æˆ–ä¼ å…¥ï¼‰
        const target = targets.find(t => t.from === unit)?.to;
        return target;
    }
    return null;
}
const REL = {
    equ: (a, b) => a === b,
    neq: (a, b) => a !== b,
    ge: (a, b) => a >= b,
    le: (a, b) => a <= b,
};

function evaluateRuleForState(rule, state) {
    const { blueOrder, redOrder } = STATE;

    // === Step 1ï¼šé˜Ÿä¼åŒ¹é… ===
    const checkTeamMatch = (sideOrder, targetList) => {
        if (sideOrder.length !== 4) return false;
        if (sideOrder[0]?.role.short !== targetList[0]) return false;
        const actualSet = new Set(sideOrder.map(u => u.role.short));
        const targetSet = new Set(targetList);
        return actualSet.size === 4 && [...actualSet].sort().join() === [...targetSet].sort().join();
    };
    const pre = rule.preconditions;
    if (!checkTeamMatch(redOrder, pre.team.red)) {
        return {
            redMatched: false,
            blueMatched: false
        };
    }
    // === Step 2ï¼šçº¢æ–¹ä½ç½®å‰æ ===
    for (let [short, axis, rel, val] of pre.redPosition) {
        const unit = getUnitByShort('red', short);
        if (!unit) return { matched: false };
        const posVal = axis === 'x-pos' ? getX(unit) : getY(unit);
        if (!REL[rel](posVal, val))
            return {
                redMatched: false,
                blueMatched: false
            }
    }

    if (!checkTeamMatch(blueOrder, pre.team.blue)) {
        return {
            redMatched: true,
            blueMatched: false,
            recommendedBlueTeam: rule.preconditions.team.blue || null,   // ['Eunha', 'Estel', ...]
            tacticName: rule.name,
            tacticDesc: rule.desc || ''
        }
    }

    let bluePositionSatisfied = true;
    if (rule.bluePosition && rule.bluePosition.length > 0) {
        for (let [short, axis, rel, val] of rule.bluePosition) {
            const unit = getUnitByShort('blue', short);
            if (!unit) {
                bluePositionSatisfied = false;
                break;
            }
            const posVal = axis === 'x-pos' ? getX(unit) : getY(unit);
            if (!REL[rel](posVal, val)) {
                bluePositionSatisfied = false;
                break;
            }
        }
    }

    // === Step 4ï¼šè¯„åˆ†è®¡ç®—ï¼ˆè‹¥è“æ–¹ä½ç½®æœªæ»¡è¶³ï¼Œscore å¼ºåˆ¶ä¸º 0ï¼‰===
    let score = 0;
    const matchedScorings = [];

    // ã€å…³é”®æ”¹åŠ¨ã€‘å…ˆæ ‡è®°æ˜¯å¦é€šè¿‡è“æ–¹å‰ç½®ï¼ˆä»…å½±å“åˆ†æ•°ï¼Œä¸é˜»æ–­ matchedï¼‰
    const passedBluePosition = bluePositionSatisfied;

    // è®¡ç®—åŸå§‹åˆ†ï¼ˆä»ç´¯åŠ ï¼Œç”¨äºæ˜¾ç¤ºæ˜ç»†ï¼‰
    for (const item of rule.scoring) {
        let ok = false;
        try {
            if (item.length === 5) {
                const [expr, axis, rel, val, pts] = item;
                const unit = resolveChar(expr);
                if (unit) {
                    const posVal = axis === 'x-pos' ? getX(unit) : getY(unit);
                    if (REL[rel](posVal, val)) {
                        ok = true; score += pts;
                    }
                }
            } else if (item.length === 7 && item[3] === 'delta') {
                const [e1, e2, axis, _, rel, val, pts] = item;
                const u1 = resolveChar(e1), u2 = resolveChar(e2);
                if (u1 && u2) {
                    const p1 = axis === 'x-pos' ? getX(u1) : getY(u1);
                    const p2 = axis === 'x-pos' ? getX(u2) : getY(u2);
                    if (REL[rel](Math.abs(p1 - p2), val)) {
                        ok = true; score += pts;
                    }
                }
            } else if (item.length === 4 && item[1] === 'lock') {
                const [fromExpr, , toExpr, pts] = item;
                const fromUnit = resolveChar(fromExpr);
                const toUnit = resolveChar(toExpr);
                if (fromUnit && toUnit) {
                    const targets = computeTargets();
                    const target = targets.find(t => t.from === fromUnit)?.to;
                    if (target === toUnit) {
                        ok = true; score += pts;
                    }
                }
            }
        } catch (e) {
            console.warn(`è¯„åˆ†é¡¹è§£æå¤±è´¥:`, item, e);
        }
        if (ok) matchedScorings.push(item);
    }

    // ã€å¼ºåˆ¶é€»è¾‘ã€‘ï¼šè‹¥è“æ–¹ä½ç½®ä¸æ»¡è¶³ â†’ æœ€ç»ˆå¾—åˆ† = 0ï¼ˆä½†ä¿ç•™åŸå§‹ matchedScorings ä¾›å±•ç¤ºï¼‰
    if (!passedBluePosition) {
        score = 0;
    }

    return {
        redMatched: true,
        blueMatched: true,
        score,
        maxScore: rule.maxScore !== undefined ? rule.maxScore : rule.scoring.reduce((s, it) => s + (it[it.length - 1] || 0), 0),
        matchedScorings,
        bluePositionSatisfied: passedBluePosition,
        // ===== æ–°å¢æ¨èå­—æ®µ =====
        recommendedBlueTeam: rule.preconditions.team.blue || null,   // ['Eunha', 'Estel', ...]
        tacticName: rule.name,
        tacticDesc: rule.desc || ''
    };
}

// === è§„åˆ™è¯„ä¼°ä¸»å‡½æ•° ===
function evaluateRule(rule) {
    return evaluateRuleForState(rule, STATE);
}

function* permutations(arr, k) {
    if (k === 0) {
        yield [];
        return;
    }
    for (let i = 0; i < arr.length; i++) {
        const rest = arr.slice(0, i).concat(arr.slice(i + 1));
        for (const perm of permutations(rest, k - 1)) {
            yield [arr[i], ...perm];
        }
    }
}

// ===== æ–°å¢ï¼šæ£€æŸ¥è§’è‰²ç«™ä½æ˜¯å¦æ»¡è¶³ bluePosition çº¦æŸ =====
function satisfiesBluePosition(units, bluePositionRules) {
    if (!bluePositionRules || bluePositionRules.length === 0) return true;
    for (const [short, axis, rel, val] of bluePositionRules) {
        const unit = units.find(u => u.role.short === short);
        if (!unit) return false;
        const posVal = axis === 'x-pos' ? unit.pos[1] : unit.pos[0];
        if (rel === 'equ' && posVal !== val) return false;
        if (rel === 'neq' && posVal === val) return false;
        if (rel === 'ge'  && posVal < val)  return false;
        if (rel === 'le'  && posVal > val)  return false;
    }
    return true;
}

function computeBestBluePlacementForRule(rule) {
    const blueTeamShorts = rule.preconditions?.team?.blue || [];
    if (!Array.isArray(blueTeamShorts) || blueTeamShorts.length === 0) return null;

    // è§’è‰²å®ä½“åŒ–
    const roles = blueTeamShorts.map(s => ALL_ROLES.find(r => r.short === s)).filter(Boolean);
    if (roles.length === 0) return null;

    // è¡¥è¶³æˆ–æˆªæ–­ä¸º 4 äººï¼ˆæŒ‰è§„åˆ™è¦æ±‚ï¼‰
    while (roles.length < 4 && roles.length > 0) roles.push(roles[roles.length % roles.length]);
    roles.length = 4;

    // é¦–ä½å›ºå®šï¼ˆè§„åˆ™è¦æ±‚è“é˜Ÿé¦–ä½ä¸¥æ ¼åŒ¹é…ï¼Œæ•…ä¿æŒ roles[0] ä¸å˜ï¼‰
    const firstRole = roles[0];
    const tailRoles = roles.slice(1); // å3äººå¾…æ’åˆ—

    // ç”Ÿæˆå3äººçš„æ‰€æœ‰æ’åˆ—ï¼ˆæœ€å¤š 3! = 6 ç§ï¼‰
    const tailPerms = [...permutations(tailRoles, 3)];
    const teamVariants = tailPerms.map(perm => [firstRole, ...perm]);
    if (tailPerms.length === 0) teamVariants.push([firstRole, ...tailRoles]); // é˜²ç©º

    // è“åŒºæ‰€æœ‰æ ¼å­ï¼šc âˆˆ [0,1,2,3], r âˆˆ [0,1,2,3,4] â†’ 20ä¸ª
    const blueCells = [];
    for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 4; c++) {
            blueCells.push([r, c]);
        }
    }

    let best = { score: -Infinity, units: null };

    // æšä¸¾ï¼šæ¯ä¸ª teamVariant + æ‰€æœ‰ 4 ä¸ªä¸é‡å¤ä½ç½®çš„æ’åˆ—ï¼ˆP(20,4)=116280 â†’ å¯æ¥å—ï¼Œå› å‰ªæï¼‰
    for (const team of teamVariants) {
        // ç”Ÿæˆæ‰€æœ‰ 4 ä¸ªä¸é‡å¤åæ ‡çš„æ’åˆ—ï¼ˆå…± P(20,4) = 116280ï¼Œä½†åŠ å‰ªæåå¤§å¹…å‡å°‘ï¼‰
        for (const posPerm of permutations(blueCells, 4)) {
            // æ„å»ºä¸´æ—¶å•ä½
            const units = team.map((role, i) => ({
                side: 'blue',
                role,
                pos: posPerm[i],
                index: i
            }));

            // âœ… ã€å…³é”®å‰ªæã€‘å…ˆæ£€æŸ¥æ˜¯å¦æ»¡è¶³ bluePosition çº¦æŸ
            if (!satisfiesBluePosition(units, rule.bluePosition)) {
                continue;
            }

            // æ„å»ºä¸´æ—¶ STATEï¼ˆæ·±æ‹·è´çº¢æ–¹ï¼Œæ›¿æ¢è“æ–¹ï¼‰
            const tempMap = Array(5).fill().map(() => Array(14).fill(null));
            const tempBlue = [];
            const tempRed = STATE.redOrder.map(u => ({
                ...u,
                pos: [...u.pos]
            }));

            // æ”¾å…¥è“æ–¹
            units.forEach(u => {
                const [r, c] = u.pos;
                tempMap[r][c] = u;
                tempBlue.push(u);
            });
            // æ”¾å…¥çº¢æ–¹
            tempRed.forEach(u => {
                const [r, c] = u.pos;
                if (r >= 0 && r < 5 && c >= 0 && c < 14) {
                    tempMap[r][c] = u;
                }
            });

            const tempState = {
                map: tempMap,
                blueOrder: tempBlue,
                redOrder: tempRed
            };

            // è¯„åˆ†ï¼ˆä½¿ç”¨ evaluateRuleForStateï¼‰
            const result = evaluateRuleForState(rule, tempState);
            if (result.matched && result.score > best.score) {
                best = {
                    score: result.score,
                    units: units.map(u => ({ ...u, pos: [...u.pos] })),
                    rawScore: result.rawScore
                };
            }
        }
    }

    return best.score > -Infinity ? best : null;
}

// === æ‰¹é‡æ£€æŸ¥æ‰€æœ‰è§„åˆ™ ===
async function checkAllRules() {
    window._ruleCache = {};

    const scorePanel = document.getElementById('scorePanel');
    const scoreContent = document.getElementById('scoreContent');
    let allResults = [];

    const rulePaths = [
        './rule/æš—åˆ€ç«é¾™è§£ç«é¾™ä¸‰åˆ‡.js',
        './rule/èå†°ç«é¾™è§£ç«é¾™ä¸‰åˆ‡.js',
        // å¯æ‰©å±•
    ];

    for (let url of rulePaths) {
        try {
            const module = await import(url + '?t=' + Date.now());
            const rule = module.default;
            const result = evaluateRule(rule);
            if (result.redMatched) allResults.push({ rule, result });
        } catch (e) {
            console.warn(`è§„åˆ™ ${url} åŠ è½½å¤±è´¥:`, e.message);
        }
    }
    let ruleIdCounter = 0;
    window._ruleCache = window._ruleCache || {};
    const ruleCache = {}; // å…¨å±€ç¼“å­˜
    // æ¸²æŸ“æ™ºèƒ½æˆ˜æœ¯é¢æ¿ï¼ˆä»…æ˜¾ç¤ºæ¨èé˜Ÿä¼ï¼Œä¸ä¾èµ–è“æ–¹å½“å‰çŠ¶æ€ï¼‰
    if (allResults.length === 0) {
        tacticPanel.style.display = 'none';
    } else {
        tacticPanel.style.display = 'block';
        let html = '';

        allResults.forEach(({ rule, result }) => {
            if (!result.recommendedBlueTeam) return; // ä»…æ˜¾ç¤ºæœ‰æ¨èçš„
            const ruleId = 'rule_' + Date.now() + '_' + (ruleIdCounter++);
            ruleCache[ruleId] = rule; // ç¼“å­˜åŸå§‹ rule å¯¹è±¡

            const blueTeam = Array.isArray(rule.preconditions?.team?.blue) ? rule.preconditions.team.blue : [];
            const teamNames = blueTeam.length > 0
                ? blueTeam.map(short => {
                    const role = ALL_ROLES.find(r => r.short === short);
                    return role ? role.name : short;
                }).join('ã€')
                : 'ï¼ˆæ¸…ç©ºç°æœ‰é˜µå®¹ï¼‰';

            html += `
            <div style="margin-bottom: 16px; padding: 14px; border: 1px solid #eee; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                    <div>
                        <div style="font-weight: 600; color: #1E88E5; font-size: 1.1rem;">${result.tacticName}</div>
                        <div style="font-size: 0.9rem; color: #666; margin-top: 4px;">${result.tacticDesc || ''}</div>
                    </div>
                    <div style="display: flex; gap: 6px;">
                        <button class="btn btn-confirm"
                                onclick="applyTactic(${JSON.stringify(blueTeam)})"
                                style="padding: 6px 12px; font-size: 0.9rem;">
                            <i class="fas fa-bolt"></i> ä¸€é”®é…ç½®
                        </button>
                        <button class="btn"
                                style="background:#6a1b9a; color:white; padding: 6px 12px; font-size: 0.9rem;"
                                onclick="doOptimalPlacement('${ruleId}')">
                            <i class="fas fa-magic"></i> ä¸€é”®ç«™ä½
                        </button>
                    </div>
                </div>
                <div style="font-size: 0.95rem;">æ¨èæˆ‘æ–¹ï¼š${teamNames}</div>
            </div>
            `;
        });

        tacticContent.innerHTML = html || '<div style="text-align:center; color:#999; padding:20px;">æš‚æ— æˆ˜æœ¯æ¨è</div>';
    }

    // æ¸²æŸ“è¯„åˆ†é¢æ¿
    if (allResults.length === 0) {
        scorePanel.style.display = 'none';
        return;
    }

    scorePanel.style.display = 'block';
    let html = '';

    allResults.forEach(({ rule, result }) => {
        if (result.blueMatched === true) {
            const pct = (result.score / result.maxScore * 100).toFixed(1);
            const color = pct >= 80 ? '#4CAF50' : pct >= 60 ? '#FF9800' : '#F44336';

            html += `
    <div style="margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #eee;">
      <div style="font-weight: 600; color: #333; margin-bottom: 6px;">
        ğŸ¯ ${rule.name}
      </div>
      <div style="display: flex; gap: 8px; margin-top: 10px;">
          <button class="btn btn-confirm" 
                  onclick='applyTactic(${JSON.stringify(blueTeam)})'
                  style="flex:1; font-size:0.9rem;">
              <i class="fas fa-bolt"></i> ä¸€é”®é…ç½®
          </button>
          <button class="btn" 
                  style="background:#6a1b9a; color:white; flex:1; font-size:0.9rem;"
                  onclick='doOptimalPlacement(${JSON.stringify(rule)})'>
              <i class="fas fa-magic"></i> ä¸€é”®ç«™ä½
          </button>
      </div>
      <div style="font-size: 12px; color: #666;">
        ${rule.desc || ''}
      </div>
    </div>
  `;
        }

    });

    scoreContent.innerHTML = html;
}

function applyTactic(shortList) {
    // 1. æ¸…ç©ºç°æœ‰è“æ–¹
    STATE.blueOrder.forEach(u => {
        const [r, c] = u.pos;
        STATE.map[r][c] = null;
    });
    STATE.blueOrder = [];

    // 2. æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨ & å»é‡
    const validRoles = [];
    const seen = new Set();
    for (const short of shortList) {
        if (seen.has(short)) continue;
        const role = ALL_ROLES.find(r => r.short === short);
        if (role) {
            validRoles.push({ role, short });
            seen.add(short);
        }
    }

    if (validRoles.length === 0) {
        showNotification('âš ï¸ æ— æœ‰æ•ˆè§’è‰²å¯é…ç½®', 'warning');
        renderMap();
        return;
    }

    // 3. ä¸€å­—æ’å¼€ï¼šè“åŒºå‰4åˆ—ï¼ˆc=0~3ï¼‰ï¼Œä»ä¸Šåˆ°ä¸‹ r=0,1,2,3,4 å¾ªç¯
    const cols = [0, 1, 2, 3]; // è“åŒºåˆ—
    const rows = [0, 1, 2, 3, 4];
    let placed = 0;

    for (let i = 0; i < validRoles.length && placed < 4; i++) {
        const c = cols[i % 4];
        const r = rows[Math.floor(i / 4) % 5];
        const { role } = validRoles[i];

        // è·³è¿‡å·²è¢«å ç”¨çš„æ ¼å­ï¼ˆæå°æ¦‚ç‡ï¼‰
        let found = false;
        for (let dr = 0; dr < 5 && !found; dr++) {
            const nr = (r + dr) % 5;
            if (!STATE.map[nr][c]) {
                const unit = { side: 'blue', role, pos: [nr, c], index: placed, isNew: true };
                STATE.map[nr][c] = unit;
                STATE.blueOrder.push(unit);
                placed++;
                found = true;
            }
        }
    }

    // 4. æ›´æ–°ç´¢å¼• & æ¸²æŸ“
    STATE.blueOrder.forEach((u, i) => u.index = i);
    renderMap();
    showNotification(`âœ… å·²é…ç½®æˆ˜æœ¯é˜µå®¹ï¼š${validRoles.map(v => v.role.name).join('ã€')}`, 'success');
}


// æ”¹åæ•´åˆï¼ˆé¿å…å†²çªï¼‰
function doOptimalPlacement(ruleId) {
    const rule = window._ruleCache[ruleId];
    if (!rule) {
        console.error('Rule not found:', ruleId);
        showNotification('âŒ è§„åˆ™ç¼“å­˜å¤±æ•ˆï¼Œè¯·é‡è¯•', 'error');
        return;
    }

    showNotification('ğŸ” æ­£åœ¨è®¡ç®—æœ€ä¼˜ç«™ä½ï¼ˆå¯èƒ½éœ€ 1~3 ç§’ï¼‰â€¦', 'info');
    requestAnimationFrame(() => {
        try {
            const best = computeBestBluePlacementForRule(rule);
            if (!best) {
                showNotification('âŒ æœªæ‰¾åˆ°æ»¡è¶³çº¦æŸçš„ç«™ä½', 'warning');
                return;
            }

            // æ¸…ç©ºè“æ–¹
            STATE.blueOrder.forEach(u => {
                const [r, c] = u.pos;
                STATE.map[r][c] = null;
            });
            STATE.blueOrder = [];

            // éƒ¨ç½²
            best.units.forEach(u => {
                const [r, c] = u.pos;
                const unit = { ...u, pos: [r, c], isNew: true };
                STATE.map[r][c] = unit;
                STATE.blueOrder.push(unit);
            });
            STATE.blueOrder.forEach((u, i) => u.index = i);

            renderMap();
            const pct = (best.score / (rule.maxScore || 100) * 100).toFixed(1);
            showNotification(`âœ… æœ€ä¼˜ç«™ä½å·²éƒ¨ç½²ï¼å¾—åˆ†: ${best.score} / ${rule.maxScore || '?'} (${pct}%)`, 'success');
        } catch (e) {
            console.error('ç«™ä½è®¡ç®—å¤±è´¥:', e);
            showNotification('âš ï¸ ç«™ä½è®¡ç®—å‡ºé”™', 'error');
        }
    });
}

// æš´éœ²ç»™å…¨å±€
window.evaluateRule = evaluateRule;
window.checkAllRules = checkAllRules;
window.applyTactic = applyTactic;
window.doOptimalPlacement = doOptimalPlacement;