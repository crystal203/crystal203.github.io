<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>秘密画板</title>
  <script src="asset.js"></script> 
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #222;
      font-family: Arial, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    /* 控制面板 */
    #controlPanel {
      padding: 10px;
      background: #333;
      color: white;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    #controlPanel button {
      padding: 6px 12px;
      cursor: pointer;
    }
    #zoomSlider {
      width: 150px;
    }
    /* 可滚动区域 */
    #scrollContainer {
      flex: 1;
      overflow: auto;
      background: #000;
      position: relative;
    }
    #bottomCanvas, #topCanvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
  
</head>
<body>
<div id="controlPanel">
  <select id="assetSelector">
    <option value="">请选择角色</option>
    <!-- 选项由 JS 填充 -->
  </select>
  <button id="loadBtn">加载</button>
  <button id="resetBtn">重置 (R)</button>
  <button id="zoomOut">−</button>
  <input type="range" id="zoomSlider" min="0.1" max="3" step="0.05" value="1" disabled>
  <button id="zoomIn">+</button>
  <span id="zoomLabel">-</span>
</div>
  <div id="scrollContainer">
    <canvas id="bottomCanvas"></canvas>
    <canvas id="topCanvas"></canvas>
  </div>

  <script>
    // DOM 元素
    const scrollContainer = document.getElementById('scrollContainer');
    const bottomCanvas = document.getElementById('bottomCanvas');
    const topCanvas = document.getElementById('topCanvas');
    const bottomCtx = bottomCanvas.getContext('2d');
    const topCtx = topCanvas.getContext('2d');
    const resetBtn = document.getElementById('resetBtn');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomLabel = document.getElementById('zoomLabel');

    // 图片和状态
    let imgA = null; // up.png
    let imgB = null; // down.png
    let scale;
    const minScale = 0.1;
    const maxScale = 3;

    // 擦除路径记录（逻辑坐标）
    const erasePaths = [];
    let isDrawing = false;

    // 初始化：加载 A
const assetSelector = document.getElementById('assetSelector');
const loadBtn = document.getElementById('loadBtn');

// 全局状态重置函数
function clearCanvas() {
  bottomCanvas.width = bottomCanvas.height = topCanvas.width = topCanvas.height = 0;
  bottomCanvas.style.width = bottomCanvas.style.height = topCanvas.style.width = topCanvas.style.height = '';
  erasePaths.length = 0;
  isDrawing = false;
}

// 填充下拉菜单（假设 asset.js 定义了 window.assetList = ['character1', 'character2', ...]）
if (window.assetList && Array.isArray(assetList)) {
  assetList.forEach(name => {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    assetSelector.appendChild(opt);
  });
}

// 加载选中资源
async function loadSelectedAsset() {
  const selected = assetSelector.value;
  if (!selected) return;

  const folder = `asset/${selected}`;
  const upPath = `${folder}/up.png`;
  const downPath = `${folder}/down.png`;

  try {
    clearCanvas();

    imgA = new Image();
    imgB = new Image();
    imgA.src = upPath;
    imgB.src = downPath;
    const imgWidth = imgA.naturalWidth;
    const imgHeight = imgA.naturalHeight;
    const containerWidth = scrollContainer.clientWidth;
    const containerHeight = scrollContainer.clientHeight;
    const fitScale = Math.min(
      containerWidth / imgWidth,
      containerHeight / imgHeight,
      maxScale
    );
    scale = Math.max(fitScale, minScale);

    zoomSlider.value = scale;
    zoomLabel.textContent = Math.round(scale * 100) + '%';
    zoomSlider.disabled = false;

    updateCanvasSize(imgWidth, imgHeight, scale);
    drawBottom(imgWidth, imgHeight);
    drawTop(imgWidth, imgHeight);
  } catch (err) {
    alert('图片加载失败，请检查 asset 文件夹结构');
    console.error(err);
  }
}

loadBtn.addEventListener('click', loadSelectedAsset);

// 重置按钮现在只在有图片时有效
function resetErasedLayer() {
  if (!imgA || !imgB) return;
  erasePaths.length = 0;
  drawTop(imgA.naturalWidth, imgA.naturalHeight);
}

    function updateCanvasSize(imgWidth, imgHeight, newScale) {
      const newWidth = imgWidth * newScale;
      const newHeight = imgHeight * newScale;
      bottomCanvas.width = topCanvas.width = newWidth;
      bottomCanvas.height = topCanvas.height = newHeight;
      bottomCanvas.style.width = topCanvas.style.width = newWidth + 'px';
      bottomCanvas.style.height = topCanvas.style.height = newHeight + 'px';
    }

    function drawBottom(imgWidth, imgHeight) {
      bottomCtx.clearRect(0, 0, bottomCanvas.width, bottomCanvas.height);
      bottomCtx.drawImage(imgB, 0, 0, bottomCanvas.width, bottomCanvas.height);
    }

    function drawTop(imgWidth, imgHeight) {
      topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
      topCtx.drawImage(imgA, 0, 0, topCanvas.width, topCanvas.height);

      if (erasePaths.length === 0) return;

      // 重放擦除路径（使用当前 scale）
      topCtx.globalCompositeOperation = 'destination-out';
      const radius = 30 * scale; // eraseRadiusLogical = 30
      for (const path of erasePaths) {
        for (const pt of path) {
          const x = pt.x * scale;
          const y = pt.y * scale;
          topCtx.beginPath();
          topCtx.arc(x, y, radius, 0, Math.PI * 2);
          topCtx.fill();
        }
      }
      topCtx.globalCompositeOperation = 'source-over';
    }

    resetBtn.addEventListener('click', resetErasedLayer);
    document.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') resetErasedLayer();
    });

    function zoomTo(newScale, clientX = null, clientY = null) {
      if (!imgA || !imgB) return;
      if (newScale < minScale) newScale = minScale;
      if (newScale > maxScale) newScale = maxScale;
      if (newScale === scale) return;

      const imgWidth = imgA.naturalWidth;
      const imgHeight = imgA.naturalHeight;

      const scrollLeft = scrollContainer.scrollLeft;
      const scrollTop = scrollContainer.scrollTop;
      const viewportCenterX = scrollLeft + scrollContainer.clientWidth / 2;
      const viewportCenterY = scrollTop + scrollContainer.clientHeight / 2;
      const logicalCenterX = viewportCenterX / scale;
      const logicalCenterY = viewportCenterY / scale;

      scale = newScale;
      zoomSlider.value = scale;
      zoomLabel.textContent = Math.round(scale * 100) + '%';

      // 关键：不再用 putImageData，而是重新绘制
      updateCanvasSize(imgWidth, imgHeight, scale);
      drawBottom(imgWidth, imgHeight);
      drawTop(imgWidth, imgHeight);

      const newScrollLeft = logicalCenterX * scale - scrollContainer.clientWidth / 2;
      const newScrollTop = logicalCenterY * scale - scrollContainer.clientHeight / 2;

      requestAnimationFrame(() => {
        scrollContainer.scrollLeft = newScrollLeft;
        scrollContainer.scrollTop = newScrollTop;
      });
    }

    zoomSlider.addEventListener('input', (e) => {
      zoomTo(parseFloat(e.target.value));
    });
    zoomInBtn.addEventListener('click', () => zoomTo(scale + 0.1));
    zoomOutBtn.addEventListener('click', () => zoomTo(scale - 0.1));

    scrollContainer.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = scale * zoomFactor;
        zoomTo(newScale, e.clientX, e.clientY);
      }
    }, { passive: false });

    // 获取逻辑坐标（图像坐标系）
    function getLogicalPos(e) {
      const rect = topCanvas.getBoundingClientRect();
      const canvasX = e.clientX - rect.left;
      const canvasY = e.clientY - rect.top;
      return {
        x: canvasX / scale,
        y: canvasY / scale
      };
    }

    function startErase(e) {
      isDrawing = true;
      const logical = getLogicalPos(e);
      erasePaths.push([logical]); // 每次 mousedown 开始新路径
      applyErase(logical.x * scale, logical.y * scale);
    }

    function continueErase(e) {
      if (!isDrawing) return;
      const logical = getLogicalPos(e);
      erasePaths[erasePaths.length - 1].push(logical);
      applyErase(logical.x * scale, logical.y * scale);
    }

    function applyErase(x, y) {
      const radius = 30 * scale;
      topCtx.globalCompositeOperation = 'destination-out';
      topCtx.beginPath();
      topCtx.arc(x, y, radius, 0, Math.PI * 2);
      topCtx.fill();
      topCtx.globalCompositeOperation = 'source-over';
    }

    function stopErase() {
      isDrawing = false;
    }

    // 鼠标事件
    topCanvas.addEventListener('mousedown', startErase);
    topCanvas.addEventListener('mousemove', continueErase);
    topCanvas.addEventListener('mouseup', stopErase);
    topCanvas.addEventListener('mouseleave', stopErase);

    // 触摸事件
    topCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startErase(e.touches[0]);
    });
    topCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      continueErase(e.touches[0]);
    });
    topCanvas.addEventListener('touchend', stopErase);
  </script>
</body>
</html>