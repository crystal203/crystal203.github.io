<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>秘密画板</title>
    <script src="asset.js"></script> 
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #controlPanel {
            padding: 10px;
            background: #333;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #controlPanel button {
            padding: 6px 12px;
            cursor: pointer;
        }
        #zoomSlider {
            width: 150px;
        }
        #scrollContainer {
            flex: 1;
            overflow: auto;
            background: #000;
            position: relative;
        }
        #topCanvas, #bottomCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none; 
        }
    </style>
</head>
<body>
    <div id="controlPanel">
        <select id="assetSelector">
            <option value="">请选择角色</option>
        </select>
        <button id="loadBtn">加载</button>
        <button id="resetBtn">重置 (R)</button>
        <button id="zoomOut">−</button>
        <input type="range" id="zoomSlider" min="0" max="1" step="0.01" value="1" disabled>
        <button id="zoomIn">+</button>
        <span id="zoomLabel">-</span>
    </div>
    <div id="scrollContainer">
        <canvas id="bottomCanvas"></canvas>
        <canvas id="topCanvas"></canvas>
    </div>
    <script>
        const scrollContainer = document.getElementById('scrollContainer');
        const bottomCanvas = document.getElementById('bottomCanvas');
        const topCanvas = document.getElementById('topCanvas');
        const bottomCtx = bottomCanvas.getContext('2d');
        const topCtx = topCanvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomLabel = document.getElementById('zoomLabel');
        let imgA = null;
        let imgB = null;
        let scale;
        const minScale = 0.1;
        const maxScale = 3;
        const erasePaths = [];
        let isDrawing = false;
        const assetSelector = document.getElementById('assetSelector');
        const loadBtn = document.getElementById('loadBtn');
        function clearCanvas() {
            bottomCanvas.width = bottomCanvas.height = topCanvas.width = topCanvas.height = 0;
            bottomCanvas.style.width = bottomCanvas.style.height = topCanvas.style.width = topCanvas.style.height = '';
            erasePaths.length = 0;
            isDrawing = false;
        }
        if (window.assetList && Array.isArray(assetList)) {
            assetList.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                assetSelector.appendChild(opt);
            });
        }
        let isLoading = false;
        async function loadSelectedAsset() {
            const selected = assetSelector.value;
            if (!selected || isLoading) return;
            isLoading = true;
            loadBtn.disabled = true;
            loadBtn.textContent = '加载中...';
            clearCanvas();
            const folder = `asset/${selected}`;
            const upPath = `${folder}/up.png`;
            const downPath = `${folder}/down.png`;
            const loadImage = (src, retries = 3) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const attempt = () => {
                        img.onload = () => resolve(img);
                        img.onerror = () => {
                            if (--retries > 0) {
                                setTimeout(attempt, 500);
                            } else {
                                reject(new Error(`Failed to load ${src}`));
                            }
                        };
                        img.src = src + '?_=' + Date.now();
                    };
                    attempt();
                });
            };
            try {
                const [loadedImgA, loadedImgB] = await Promise.all([
                    loadImage(upPath),
                    loadImage(downPath)
                ]);
                imgA = loadedImgA;
                imgB = loadedImgB;
                const imgWidth = imgA.naturalWidth;
                const imgHeight = imgA.naturalHeight;
                const containerWidth = scrollContainer.clientWidth;
                const containerHeight = scrollContainer.clientHeight;
                const fitScale = Math.min(
                    containerWidth / imgWidth,
                    containerHeight / imgHeight,
                    maxScale
                );
                scale = Math.max(fitScale, minScale);
                zoomSlider.value = scaleToValue(scale);
                zoomLabel.textContent = Math.round(scale * 100) + '%';
                zoomSlider.disabled = false;
                updateCanvasSize(imgWidth, imgHeight, scale);
                drawBottom(imgWidth, imgHeight);
                drawTop(imgWidth, imgHeight);
            } catch (err) {
                alert('网络波动，请重试');
                console.error(err);
            } finally {
                isLoading = false;
                loadBtn.disabled = false;
                loadBtn.textContent = '加载';
            }
        }
        loadBtn.addEventListener('click', loadSelectedAsset);
        function resetErasedLayer() {
            if (!imgA || !imgB) return;
            erasePaths.length = 0;
            drawTop(imgA.naturalWidth, imgA.naturalHeight);
        }
        function updateCanvasSize(imgWidth, imgHeight, newScale) {
            const newWidth = imgWidth * newScale;
            const newHeight = imgHeight * newScale;
            bottomCanvas.width = topCanvas.width = newWidth;
            bottomCanvas.height = topCanvas.height = newHeight;
            bottomCanvas.style.width = topCanvas.style.width = newWidth + 'px';
            bottomCanvas.style.height = topCanvas.style.height = newHeight + 'px';
        }
        function drawBottom(imgWidth, imgHeight) {
            bottomCtx.clearRect(0, 0, bottomCanvas.width, bottomCanvas.height);
            bottomCtx.drawImage(imgB, 0, 0, bottomCanvas.width, bottomCanvas.height);
        }
        function drawTop(imgWidth, imgHeight) {
            topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
            topCtx.drawImage(imgA, 0, 0, topCanvas.width, topCanvas.height);
            if (erasePaths.length === 0) return;
            topCtx.globalCompositeOperation = 'destination-out';
            const radius = 30 * scale;
            for (const path of erasePaths) {
                for (const pt of path) {
                    const x = pt.x * scale;
                    const y = pt.y * scale;
                    topCtx.beginPath();
                    topCtx.arc(x, y, radius, 0, Math.PI * 2);
                    topCtx.fill();
                }
            }
            topCtx.globalCompositeOperation = 'source-over';
        }
        resetBtn.addEventListener('click', resetErasedLayer);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') resetErasedLayer();
        });
        function valueToScale(v) {
            const logMin = Math.log(minScale);
            const logMax = Math.log(maxScale);
            return Math.exp(logMin + v * (logMax - logMin));
        }
        function scaleToValue(s) {
            const logMin = Math.log(minScale);
            const logMax = Math.log(maxScale);
            const logS = Math.log(s);
            return (logS - logMin) / (logMax - logMin);
        }
        function zoomTo(newScale, clientX = null, clientY = null) {
            if (!imgA || !imgB) return;
            if (newScale < minScale) newScale = minScale;
            if (newScale > maxScale) newScale = maxScale;
            if (Math.abs(newScale - scale) < 1e-6) return;
            const imgWidth = imgA.naturalWidth;
            const imgHeight = imgA.naturalHeight;
            const scrollLeft = scrollContainer.scrollLeft;
            const scrollTop = scrollContainer.scrollTop;
            const viewportCenterX = scrollLeft + scrollContainer.clientWidth / 2;
            const viewportCenterY = scrollTop + scrollContainer.clientHeight / 2;
            const logicalCenterX = viewportCenterX / scale;
            const logicalCenterY = viewportCenterY / scale;
            scale = newScale;
            zoomSlider.value = scaleToValue(scale);
            zoomLabel.textContent = Math.round(scale * 100) + '%';
            updateCanvasSize(imgWidth, imgHeight, scale);
            drawBottom(imgWidth, imgHeight);
            drawTop(imgWidth, imgHeight);
            const newScrollLeft = logicalCenterX * scale - scrollContainer.clientWidth / 2;
            const newScrollTop = logicalCenterY * scale - scrollContainer.clientHeight / 2;
            requestAnimationFrame(() => {
                scrollContainer.scrollLeft = newScrollLeft;
                scrollContainer.scrollTop = newScrollTop;
            });
        }
        zoomSlider.addEventListener('input', (e) => {
            const v = parseFloat(e.target.value);
            const newScale = valueToScale(v);
            zoomTo(newScale);
        });
        zoomInBtn.addEventListener('click', () => zoomTo(scale + 0.1));
        zoomOutBtn.addEventListener('click', () => zoomTo(scale - 0.1));
        scrollContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * zoomFactor;
                zoomTo(newScale, e.clientX, e.clientY);
            }
        }, { passive: false });
        function getLogicalPos(e) {
            const rect = topCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            return {
                x: canvasX / scale,
                y: canvasY / scale
            };
        }
        function startErase(e) {
            isDrawing = true;
            const logical = getLogicalPos(e);
            erasePaths.push([logical]); // 每次 mousedown 开始新路径
            applyErase(logical.x * scale, logical.y * scale);
        }
        function continueErase(e) {
            if (!isDrawing) return;
            const logical = getLogicalPos(e);
            erasePaths[erasePaths.length - 1].push(logical);
            applyErase(logical.x * scale, logical.y * scale);
        }
        function applyErase(x, y) {
            const radius = 30 * scale;
            topCtx.globalCompositeOperation = 'destination-out';
            topCtx.beginPath();
            topCtx.arc(x, y, radius, 0, Math.PI * 2);
            topCtx.fill();
            topCtx.globalCompositeOperation = 'source-over';
        }
        function stopErase() {
            isDrawing = false;
        }
        let touchStartPoints = [];
        let isPanning = false;
        function handleTouchStart(e) {
            if (!imgA || !imgB) return;
            e.preventDefault();
            touchStartPoints = Array.from(e.touches).map(t => ({
                x: t.clientX,
                y: t.clientY,
                id: t.identifier
            }));
            if (e.touches.length === 1) {
                startErase(e.touches[0]);
            } else if (e.touches.length === 2) {
                isPanning = true;
            }
        }
        function handleTouchMove(e) {
            if (!imgA || !imgB) return;
            e.preventDefault();
            if (e.touches.length === 1 && !isPanning) {
                continueErase(e.touches[0]);
            } else if (e.touches.length === 2 && isPanning) {
                const dx = e.touches[0].clientX - touchStartPoints[0].x;
                const dy = e.touches[0].clientY - touchStartPoints[0].y;
                const prevCenterX = (touchStartPoints[0].x + touchStartPoints[1].x) / 2;
                const prevCenterY = (touchStartPoints[0].y + touchStartPoints[1].y) / 2;
                const currCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const currCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                const ddx = currCenterX - prevCenterX;
                const ddy = currCenterY - prevCenterY;
                scrollContainer.scrollLeft -= ddx;
                scrollContainer.scrollTop -= ddy;
                touchStartPoints = Array.from(e.touches).map(t => ({
                    x: t.clientX,
                    y: t.clientY,
                    id: t.identifier
                }));
            }
        }
        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                stopErase();
                isPanning = false;
                touchStartPoints = [];
            } else if (e.touches.length === 1) {
                isPanning = false;
                startErase(e.touches[0]);
            }
        }
        topCanvas.addEventListener('touchstart', handleTouchStart);
        topCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        topCanvas.addEventListener('touchend', handleTouchEnd);
        topCanvas.addEventListener('touchcancel', handleTouchEnd);
        topCanvas.addEventListener('mousedown', startErase);
        topCanvas.addEventListener('mousemove', continueErase);
        topCanvas.addEventListener('mouseup', stopErase);
        topCanvas.addEventListener('mouseleave', stopErase);
    </script>
</body>
</html>