<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>秘密画板</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #controlPanel {
            padding: 10px;
            background: #333;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #controlPanel button {
            padding: 6px 12px;
            cursor: pointer;
        }
        #zoomSlider {
            width: 150px;
        }
        #scrollContainer {
            flex: 1;
            overflow: auto;
            background: #000;
            position: relative;
        }
        #topCanvas, #bottomCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none; 
        }
    </style>
</head>
<body>
    <script src="asset.js"></script> 
    <div id="controlPanel">
        <select id="assetSelector">
            <option value="">请选择角色</option>
        </select>
        <button id="loadBtn">加载</button>
        <button id="resetBtn">重置 (R)</button>
        <button id="zoomOut">−</button>
        <input type="range" id="zoomSlider" min="0" max="1" step="0.01" value="1" disabled>
        <button id="zoomIn">+</button>
        <span id="zoomLabel">-</span>
        <label style="display: flex; align-items: center; gap: 4px;">
        <input type="checkbox" id="pinchZoomToggle" checked>
            双指缩放（移动端）
        </label>
    </div>
    <div id="scrollContainer">
        <canvas id="bottomCanvas"></canvas>
        <canvas id="topCanvas"></canvas>
    </div>
    <script>
        const scrollContainer = document.getElementById('scrollContainer');
        const bottomCanvas = document.getElementById('bottomCanvas');
        const topCanvas = document.getElementById('topCanvas');
        const bottomCtx = bottomCanvas.getContext('2d');
        const topCtx = topCanvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomLabel = document.getElementById('zoomLabel');
        const pinchZoomToggle = document.getElementById('pinchZoomToggle');
        let imgA = null;
        let imgB = null;
        let scale;
        const minScale = 0.1;
        const maxScale = 3;
        const erasePaths = [];
        let isDrawing = false;
        let decryptedDownBitmap = null;
        const assetSelector = document.getElementById('assetSelector');
        const loadBtn = document.getElementById('loadBtn');
        function clearCanvas() {
            bottomCanvas.width = bottomCanvas.height = topCanvas.width = topCanvas.height = 0;
            bottomCanvas.style.width = bottomCanvas.style.height = topCanvas.style.width = topCanvas.style.height = '';
            erasePaths.length = 0;
            isDrawing = false;
        }
        if (assetList && Array.isArray(assetList)) {
            assetList.forEach(item => {
                const opt = document.createElement('option');
                opt.value = item.name;
                opt.textContent = item.name;
                assetSelector.appendChild(opt);
            });
        }
        let isLoading = false;
        async function loadSelectedAsset(retryCount = 0) {
            if (typeof(retryCount) !== "Number") retryCount = 0;
            const selected = assetSelector.value;
            if (!selected || isLoading) return;
            isLoading = true;
            loadBtn.disabled = true;
            clearCanvas();
            const loadingText = document.createElement('div');
            loadingText.id = 'loadingIndicator';
            loadingText.textContent = '加载中...';
            loadingText.style.position = 'absolute';
            loadingText.style.top = '50%';
            loadingText.style.left = '50%';
            loadingText.style.transform = 'translate(-50%, -50%)';
            loadingText.style.color = 'white';
            loadingText.style.fontSize = '18px';
            loadingText.style.zIndex = '10';
            scrollContainer.appendChild(loadingText);
            const folder = `asset/${selected}`;
            let upPath = `https://cdn.jsdelivr.net/gh/crystal203/crystal203.github.io@master/secret/asset/${encodeURIComponent(selected)}/up.png`;
            let downPath = `https://cdn.jsdelivr.net/gh/crystal203/crystal203.github.io@master/secret/asset/${encodeURIComponent(selected)}/down.png`;
            if (retryCount === 2) {
                upPath = `https://crystal203.github.io/secret/asset/${encodeURIComponent(selected)}/up.png`;
                downPath = `https://crystal203.github.io/secret/asset/${encodeURIComponent(selected)}/down.png`;
            }
            try {
                const [loadedImgA, loadedImgB] = await Promise.all([
                    new Promise((resolve, reject) => {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('up.png 加载失败'));
                        img.src = upPath;
                    }),
                    new Promise((resolve, reject) => {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('down.png 加载失败'));
                        img.src = downPath;
                    })
                ]);
                loadingText.remove();
                imgA = loadedImgA;
                imgB = loadedImgB;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = imgB.naturalWidth;
                tempCanvas.height = imgB.naturalHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(imgB, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, imgB.naturalWidth, imgB.naturalHeight);
                const decryptedData = await decryptBlockImageData(
                    imageData,
                    imgB.naturalWidth,
                    imgB.naturalHeight,
                    DECRYPT_KEY
                );
                tempCtx.putImageData(decryptedData, 0, 0);
                decryptedDownBitmap = await createImageBitmap(tempCanvas);
                const imgWidth = imgA.naturalWidth;
                const imgHeight = imgA.naturalHeight;
                const containerWidth = scrollContainer.clientWidth;
                const containerHeight = scrollContainer.clientHeight;
                const fitScale = Math.min(
                    containerWidth / imgWidth,
                    containerHeight / imgHeight,
                    maxScale
                );
                scale = Math.max(fitScale, minScale);
                zoomSlider.value = scaleToValue(scale);
                zoomLabel.textContent = Math.round(scale * 100) + '%';
                zoomSlider.disabled = false;
                updateCanvasSize(imgWidth, imgHeight, scale);
                bottomCtx.clearRect(0, 0, bottomCanvas.width, bottomCanvas.height);
                bottomCtx.drawImage(decryptedDownBitmap, 0, 0, bottomCanvas.width, bottomCanvas.height);
                drawTop(imgWidth, imgHeight);

                isLoading = false;
                loadBtn.disabled = false;
            } catch (err) {
                loadingText.remove();
                isLoading = false;
                loadBtn.disabled = false;
                const maxRetries = 3;
                if (retryCount < maxRetries) {
                    setTimeout(() => {
                        loadSelectedAsset(retryCount + 1);
                    }, 800);
                } else {
                    alert('图片加载失败，请检查网络或稍后重试');
                    console.error('加载失败（已重试 ' + retryCount + ' 次）:', err);
                }
            }
        }
        function getUrlParam(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        window.addEventListener('DOMContentLoaded', () => {
            const cParam = getUrlParam('c');
            if (cParam && assetList && assetList.some(item => item.name === cParam)) {
                assetSelector.value = cParam;
                setTimeout(() => {
                    if (!isLoading) {
                        loadSelectedAsset();
                    }
                }, 100);
            }
        });
        loadBtn.addEventListener('click', loadSelectedAsset);
        function drawBottom(imgWidth, imgHeight) {
            bottomCtx.clearRect(0, 0, bottomCanvas.width, bottomCanvas.height);
            if (decryptedDownBitmap) {
                bottomCtx.drawImage(decryptedDownBitmap, 0, 0, bottomCanvas.width, bottomCanvas.height);
            }
        }
        function resetErasedLayer() {
            if (!imgA || !imgB) return;
            erasePaths.length = 0;
            drawTop(imgA.naturalWidth, imgA.naturalHeight);
        }
        function updateCanvasSize(imgWidth, imgHeight, newScale) {
            const newWidth = imgWidth * newScale;
            const newHeight = imgHeight * newScale;
            bottomCanvas.width = topCanvas.width = newWidth;
            bottomCanvas.height = topCanvas.height = newHeight;
            bottomCanvas.style.width = topCanvas.style.width = newWidth + 'px';
            bottomCanvas.style.height = topCanvas.style.height = newHeight + 'px';
        }
        function drawTop(imgWidth, imgHeight) {
            topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
            topCtx.drawImage(imgA, 0, 0, topCanvas.width, topCanvas.height);
            if (erasePaths.length === 0) return;
            topCtx.globalCompositeOperation = 'destination-out';
            const radius = 30 * scale;
            for (const path of erasePaths) {
                for (const pt of path) {
                    const x = pt.x * scale;
                    const y = pt.y * scale;
                    topCtx.beginPath();
                    topCtx.arc(x, y, radius, 0, Math.PI * 2);
                    topCtx.fill();
                }
            }
            topCtx.globalCompositeOperation = 'source-over';
        }
        resetBtn.addEventListener('click', resetErasedLayer);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') resetErasedLayer();
        });
        function valueToScale(v) {
            const logMin = Math.log(minScale);
            const logMax = Math.log(maxScale);
            return Math.exp(logMin + v * (logMax - logMin));
        }
        function scaleToValue(s) {
            const logMin = Math.log(minScale);
            const logMax = Math.log(maxScale);
            const logS = Math.log(s);
            return (logS - logMin) / (logMax - logMin);
        }
        function zoomTo(newScale, clientX = null, clientY = null) {
            if (!imgA || !imgB) return;
            if (newScale < minScale) newScale = minScale;
            if (newScale > maxScale) newScale = maxScale;
            if (Math.abs(newScale - scale) < 1e-6) return;
            const imgWidth = imgA.naturalWidth;
            const imgHeight = imgA.naturalHeight;
            const scrollLeft = scrollContainer.scrollLeft;
            const scrollTop = scrollContainer.scrollTop;
            const viewportCenterX = scrollLeft + scrollContainer.clientWidth / 2;
            const viewportCenterY = scrollTop + scrollContainer.clientHeight / 2;
            const logicalCenterX = viewportCenterX / scale;
            const logicalCenterY = viewportCenterY / scale;
            scale = newScale;
            zoomSlider.value = scaleToValue(scale);
            zoomLabel.textContent = Math.round(scale * 100) + '%';
            updateCanvasSize(imgWidth, imgHeight, scale);
            drawBottom(imgWidth, imgHeight);
            drawTop(imgWidth, imgHeight);
            const newScrollLeft = logicalCenterX * scale - scrollContainer.clientWidth / 2;
            const newScrollTop = logicalCenterY * scale - scrollContainer.clientHeight / 2;
            requestAnimationFrame(() => {
                scrollContainer.scrollLeft = newScrollLeft;
                scrollContainer.scrollTop = newScrollTop;
            });
        }
        zoomSlider.addEventListener('input', (e) => {
            const v = parseFloat(e.target.value);
            const newScale = valueToScale(v);
            zoomTo(newScale);
        });
        zoomInBtn.addEventListener('click', () => zoomTo(scale + 0.1));
        zoomOutBtn.addEventListener('click', () => zoomTo(scale - 0.1));
        scrollContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * zoomFactor;
                zoomTo(newScale, e.clientX, e.clientY);
            }
        }, { passive: false });
        function getLogicalPos(e) {
            const rect = topCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            return {
                x: canvasX / scale,
                y: canvasY / scale
            };
        }
        function startErase(e) {
            isDrawing = true;
            const logical = getLogicalPos(e);
            erasePaths.push([logical]);
            applyErase(logical.x * scale, logical.y * scale);
        }
        function continueErase(e) {
            if (!isDrawing) return;
            const logical = getLogicalPos(e);
            erasePaths[erasePaths.length - 1].push(logical);
            applyErase(logical.x * scale, logical.y * scale);
        }
        function applyErase(x, y) {
            const radius = 30 * scale;
            topCtx.globalCompositeOperation = 'destination-out';
            topCtx.beginPath();
            topCtx.arc(x, y, radius, 0, Math.PI * 2);
            topCtx.fill();
            topCtx.globalCompositeOperation = 'source-over';
        }
        function stopErase() {
            isDrawing = false;
        }

        let touchStartPoints = [];
        let isPanning = false;
        let initialPinchDistance = null;
        let initialScale = null;
        const PINCH_THRESHOLD = 20;

        function getDistance(p1, p2) {
            const dx = p1.clientX - p2.clientX;
            const dy = p1.clientY - p2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getMidpoint(p1, p2) {
            return {
                x: (p1.clientX + p2.clientX) / 2,
                y: (p1.clientY + p2.clientY) / 2
            };
        }

        function handleTouchMove(e) {
            if (!imgA || !imgB) return;
            e.preventDefault();
            if (e.touches.length === 1 && !isPanning) {
                continueErase(e.touches[0]);
            } else if (e.touches.length === 2) {
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                const distanceDelta = Math.abs(currentDistance - initialPinchDistance);
                const midpoint = getMidpoint(e.touches[0], e.touches[1]);

                if (pinchZoomToggle.checked && distanceDelta > PINCH_THRESHOLD) {
                    const pinchScale = currentDistance / initialPinchDistance;
                    const newScale = initialScale * pinchScale;
                    zoomTo(newScale, midpoint.x, midpoint.y);
                    initialPinchDistance = currentDistance;
                    initialScale = scale;
                    isPanning = false;
                } else {
                    if (!isPanning) {
                        isPanning = true;
                        touchStartPoints = Array.from(e.touches).map(t => ({
                            clientX: t.clientX,
                            clientY: t.clientY,
                            id: t.identifier
                        }));
                    } else {
                        const prevCenterX = (touchStartPoints[0].clientX + touchStartPoints[1].clientX) / 2;
                        const prevCenterY = (touchStartPoints[0].clientY + touchStartPoints[1].clientY) / 2;
                        const currCenterX = midpoint.x;
                        const currCenterY = midpoint.y;
                        const ddx = currCenterX - prevCenterX;
                        const ddy = currCenterY - prevCenterY;
                        scrollContainer.scrollLeft -= ddx;
                        scrollContainer.scrollTop -= ddy;
                        touchStartPoints = Array.from(e.touches).map(t => ({
                            clientX: t.clientX,
                            clientY: t.clientY,
                            id: t.identifier
                        }));
                    }
                }
            }
        }

        function handleTouchStart(e) {
            if (!imgA || !imgB) return;
            e.preventDefault();
            touchStartPoints = Array.from(e.touches).map(t => ({
                clientX: t.clientX,
                clientY: t.clientY,
                id: t.identifier
            }));
            if (e.touches.length === 1) {
                startErase(e.touches[0]);
            } else if (e.touches.length === 2) {
                isPanning = false;
                initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                initialScale = scale;
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                stopErase();
                isPanning = false;
                initialPinchDistance = null;
                initialScale = null;
                touchStartPoints = [];
            } else if (e.touches.length === 1) {
                isPanning = false;
                initialPinchDistance = null;
                initialScale = null;
                setTimeout(() => {
                    if (e.touches[0]) startErase(e.touches[0]);
                }, 0);
            }
        }

        const DECRYPT_KEY = "your-secret-key-2025";
        const BLOCK_SIZE = 128;

        function simpleHashU32(str) {
            let h = 5381;
            const bytes = new TextEncoder().encode(str);
            for (let i = 0; i < bytes.length; i++) {
                h = ((h * 33) ^ bytes[i]) >>> 0;
            }
            return h;
        }

        function simpleHashByte(str) {
            return simpleHashU32(str) & 0xFF;
        }

        function lcgNext(state) {
            return (1664525 * state + 1013904223) >>> 0;
        }

        function generatePerm(n, seed) {
            if (seed === 0) seed = 1;
            let state = seed;
            const perm = Array.from({ length: n }, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                state = lcgNext(state);
                const j = state % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }
            return perm;
        }
        async function decryptBlockImageData(imgData, width, height, key) {
            const data = imgData.data;
            const blockW = Math.floor(width / BLOCK_SIZE); 
            const blockH = Math.floor(height / BLOCK_SIZE);
            const totalBlocks = blockW * blockH;
            if (totalBlocks === 0) {
                return new ImageData(new Uint8ClampedArray(data), width, height);
            }
            const permSeed = simpleHashU32(key + "_block_perm");
            const perm = generatePerm(totalBlocks, permSeed);
            const invPerm = new Array(totalBlocks);
            for (let i = 0; i < totalBlocks; i++) {
                invPerm[perm[i]] = i;
            }
            const newData = new Uint8ClampedArray(data);
            for (let k = 0; k < totalBlocks; k++) {
                const i = invPerm[k];
                //const xorVal = simpleHashByte(key + `_xor_${i}`);
                const xorVal = 0;
                const srcX = (i % blockW) * BLOCK_SIZE;
                const srcY = Math.floor(i / blockW) * BLOCK_SIZE;
                const dstX = (k % blockW) * BLOCK_SIZE;
                const dstY = Math.floor(k / blockW) * BLOCK_SIZE;
                for (let dy = 0; dy < BLOCK_SIZE; dy++) {
                    for (let dx = 0; dx < BLOCK_SIZE; dx++) {
                        const srcIdx = ((srcY + dy) * width + (srcX + dx)) * 4;
                        const dstIdx = ((dstY + dy) * width + (dstX + dx)) * 4;
                        newData[dstIdx]     = data[srcIdx]     ^ xorVal;
                        newData[dstIdx + 1] = data[srcIdx + 1] ^ xorVal;
                        newData[dstIdx + 2] = data[srcIdx + 2] ^ xorVal;
                        newData[dstIdx + 3] = data[srcIdx + 3];
                    }
                }
            }
            return new ImageData(newData, width, height);
        }
        topCanvas.addEventListener('touchstart', handleTouchStart);
        topCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        topCanvas.addEventListener('touchend', handleTouchEnd);
        topCanvas.addEventListener('touchcancel', handleTouchEnd);
        topCanvas.addEventListener('mousedown', startErase);
        topCanvas.addEventListener('mousemove', continueErase);
        topCanvas.addEventListener('mouseup', stopErase);
        topCanvas.addEventListener('mouseleave', stopErase);
    </script>
</body>
</html>