<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>秘密画板</title>
    <script src="asset.js"></script> 
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #controlPanel {
            padding: 10px;
            background: #333;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #controlPanel button {
            padding: 6px 12px;
            cursor: pointer;
        }
        #zoomSlider {
            width: 150px;
        }
        #scrollContainer {
            flex: 1;
            overflow: auto;
            background: #000;
            position: relative;
        }
        #topCanvas, #bottomCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none; 
        }
    </style>
</head>
<body>
    <div id="controlPanel">
        <select id="assetSelector">
            <option value="">请选择角色</option>
        </select>
        <button id="loadBtn">加载</button>
        <button id="resetBtn">重置 (R)</button>
        <button id="zoomOut">−</button>
        <input type="range" id="zoomSlider" min="0" max="1" step="0.01" value="1" disabled>
        <button id="zoomIn">+</button>
        <span id="zoomLabel">-</span>
    </div>
    <div id="scrollContainer">
        <canvas id="bottomCanvas"></canvas>
        <canvas id="topCanvas"></canvas>
    </div>
    <script>
        const scrollContainer = document.getElementById('scrollContainer');
        const bottomCanvas = document.getElementById('bottomCanvas');
        const topCanvas = document.getElementById('topCanvas');
        const bottomCtx = bottomCanvas.getContext('2d');
        const topCtx = topCanvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomLabel = document.getElementById('zoomLabel');
        let imgA = null;
        let imgB = null;
        let scale;
        const minScale = 0.1;
        const maxScale = 3;
        const erasePaths = [];
        let isDrawing = false;
        let decryptedDownBitmap = null;
        const assetSelector = document.getElementById('assetSelector');
        const loadBtn = document.getElementById('loadBtn');
        function clearCanvas() {
            bottomCanvas.width = bottomCanvas.height = topCanvas.width = topCanvas.height = 0;
            bottomCanvas.style.width = bottomCanvas.style.height = topCanvas.style.width = topCanvas.style.height = '';
            erasePaths.length = 0;
            isDrawing = false;
        }
        if (window.assetList && Array.isArray(assetList)) {
            assetList.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                assetSelector.appendChild(opt);
            });
        }
        let isLoading = false;
        async function loadSelectedAsset() {
            const selected = assetSelector.value;
            if (!selected) return;
            clearCanvas();
            const folder = `asset/${selected}`;
            const upPath = `${folder}/up.png`;
            const downPath = `${folder}/down.png`;

            try {
                const [loadedImgA, loadedImgB] = await Promise.all([
                    new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.onload = () => resolve(img);
                        img.src = upPath;
                    }),
                    new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.onload = () => resolve(img);
                        img.src = downPath;
                    })
                ]);

                imgA = loadedImgA;
                imgB = loadedImgB;

                // === 关键：在此处解密 down.png 为 ImageBitmap ===
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = imgB.naturalWidth;
                tempCanvas.height = imgB.naturalHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(imgB, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, imgB.naturalWidth, imgB.naturalHeight);
                const decryptedData = await decryptBlockImageData(
                    imageData,
                    imgB.naturalWidth,
                    imgB.naturalHeight,
                    DECRYPT_KEY
                );
                tempCtx.putImageData(decryptedData, 0, 0);
                decryptedDownBitmap = await createImageBitmap(tempCanvas); // ← 缓存解密结果

                // 继续原有逻辑
                const imgWidth = imgA.naturalWidth;
                const imgHeight = imgA.naturalHeight;
                const containerWidth = scrollContainer.clientWidth;
                const containerHeight = scrollContainer.clientHeight;
                const fitScale = Math.min(
                    containerWidth / imgWidth,
                    containerHeight / imgHeight,
                    maxScale
                );
                scale = Math.max(fitScale, minScale);
                zoomSlider.value = scaleToValue(scale);
                zoomLabel.textContent = Math.round(scale * 100) + '%';
                zoomSlider.disabled = false;

                updateCanvasSize(imgWidth, imgHeight, scale);
                // 直接绘制解密后的 bitmap
                bottomCtx.clearRect(0, 0, bottomCanvas.width, bottomCanvas.height);
                bottomCtx.drawImage(decryptedDownBitmap, 0, 0, bottomCanvas.width, bottomCanvas.height);
                drawTop(imgWidth, imgHeight);
            } catch (err) {
                alert('网络波动，请重试');
                console.error(err);
            }
        }
        loadBtn.addEventListener('click', loadSelectedAsset);
        function drawBottom(imgWidth, imgHeight) {
            bottomCtx.clearRect(0, 0, bottomCanvas.width, bottomCanvas.height);
            if (decryptedDownBitmap) {
                bottomCtx.drawImage(decryptedDownBitmap, 0, 0, bottomCanvas.width, bottomCanvas.height);
            }
        }
        function resetErasedLayer() {
            if (!imgA || !imgB) return;
            erasePaths.length = 0;
            drawTop(imgA.naturalWidth, imgA.naturalHeight);
        }
        function updateCanvasSize(imgWidth, imgHeight, newScale) {
            const newWidth = imgWidth * newScale;
            const newHeight = imgHeight * newScale;
            bottomCanvas.width = topCanvas.width = newWidth;
            bottomCanvas.height = topCanvas.height = newHeight;
            bottomCanvas.style.width = topCanvas.style.width = newWidth + 'px';
            bottomCanvas.style.height = topCanvas.style.height = newHeight + 'px';
        }
        function drawTop(imgWidth, imgHeight) {
            topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
            topCtx.drawImage(imgA, 0, 0, topCanvas.width, topCanvas.height);
            if (erasePaths.length === 0) return;
            topCtx.globalCompositeOperation = 'destination-out';
            const radius = 30 * scale;
            for (const path of erasePaths) {
                for (const pt of path) {
                    const x = pt.x * scale;
                    const y = pt.y * scale;
                    topCtx.beginPath();
                    topCtx.arc(x, y, radius, 0, Math.PI * 2);
                    topCtx.fill();
                }
            }
            topCtx.globalCompositeOperation = 'source-over';
        }
        resetBtn.addEventListener('click', resetErasedLayer);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') resetErasedLayer();
        });
        function valueToScale(v) {
            const logMin = Math.log(minScale);
            const logMax = Math.log(maxScale);
            return Math.exp(logMin + v * (logMax - logMin));
        }
        function scaleToValue(s) {
            const logMin = Math.log(minScale);
            const logMax = Math.log(maxScale);
            const logS = Math.log(s);
            return (logS - logMin) / (logMax - logMin);
        }
        function zoomTo(newScale, clientX = null, clientY = null) {
            if (!imgA || !imgB) return;
            if (newScale < minScale) newScale = minScale;
            if (newScale > maxScale) newScale = maxScale;
            if (Math.abs(newScale - scale) < 1e-6) return;
            const imgWidth = imgA.naturalWidth;
            const imgHeight = imgA.naturalHeight;
            const scrollLeft = scrollContainer.scrollLeft;
            const scrollTop = scrollContainer.scrollTop;
            const viewportCenterX = scrollLeft + scrollContainer.clientWidth / 2;
            const viewportCenterY = scrollTop + scrollContainer.clientHeight / 2;
            const logicalCenterX = viewportCenterX / scale;
            const logicalCenterY = viewportCenterY / scale;
            scale = newScale;
            zoomSlider.value = scaleToValue(scale);
            zoomLabel.textContent = Math.round(scale * 100) + '%';
            updateCanvasSize(imgWidth, imgHeight, scale);
            drawBottom(imgWidth, imgHeight);
            drawTop(imgWidth, imgHeight);
            const newScrollLeft = logicalCenterX * scale - scrollContainer.clientWidth / 2;
            const newScrollTop = logicalCenterY * scale - scrollContainer.clientHeight / 2;
            requestAnimationFrame(() => {
                scrollContainer.scrollLeft = newScrollLeft;
                scrollContainer.scrollTop = newScrollTop;
            });
        }
        zoomSlider.addEventListener('input', (e) => {
            const v = parseFloat(e.target.value);
            const newScale = valueToScale(v);
            zoomTo(newScale);
        });
        zoomInBtn.addEventListener('click', () => zoomTo(scale + 0.1));
        zoomOutBtn.addEventListener('click', () => zoomTo(scale - 0.1));
        scrollContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * zoomFactor;
                zoomTo(newScale, e.clientX, e.clientY);
            }
        }, { passive: false });
        function getLogicalPos(e) {
            const rect = topCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            return {
                x: canvasX / scale,
                y: canvasY / scale
            };
        }
        function startErase(e) {
            isDrawing = true;
            const logical = getLogicalPos(e);
            erasePaths.push([logical]); // 每次 mousedown 开始新路径
            applyErase(logical.x * scale, logical.y * scale);
        }
        function continueErase(e) {
            if (!isDrawing) return;
            const logical = getLogicalPos(e);
            erasePaths[erasePaths.length - 1].push(logical);
            applyErase(logical.x * scale, logical.y * scale);
        }
        function applyErase(x, y) {
            const radius = 30 * scale;
            topCtx.globalCompositeOperation = 'destination-out';
            topCtx.beginPath();
            topCtx.arc(x, y, radius, 0, Math.PI * 2);
            topCtx.fill();
            topCtx.globalCompositeOperation = 'source-over';
        }
        function stopErase() {
            isDrawing = false;
        }
        let touchStartPoints = [];
        let isPanning = false;
        function handleTouchStart(e) {
            if (!imgA || !imgB) return;
            e.preventDefault();
            touchStartPoints = Array.from(e.touches).map(t => ({
                x: t.clientX,
                y: t.clientY,
                id: t.identifier
            }));
            if (e.touches.length === 1) {
                startErase(e.touches[0]);
            } else if (e.touches.length === 2) {
                isPanning = true;
            }
        }
        function handleTouchMove(e) {
            if (!imgA || !imgB) return;
            e.preventDefault();
            if (e.touches.length === 1 && !isPanning) {
                continueErase(e.touches[0]);
            } else if (e.touches.length === 2 && isPanning) {
                const dx = e.touches[0].clientX - touchStartPoints[0].x;
                const dy = e.touches[0].clientY - touchStartPoints[0].y;
                const prevCenterX = (touchStartPoints[0].x + touchStartPoints[1].x) / 2;
                const prevCenterY = (touchStartPoints[0].y + touchStartPoints[1].y) / 2;
                const currCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const currCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                const ddx = currCenterX - prevCenterX;
                const ddy = currCenterY - prevCenterY;
                scrollContainer.scrollLeft -= ddx;
                scrollContainer.scrollTop -= ddy;
                touchStartPoints = Array.from(e.touches).map(t => ({
                    x: t.clientX,
                    y: t.clientY,
                    id: t.identifier
                }));
            }
        }
        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                stopErase();
                isPanning = false;
                touchStartPoints = [];
            } else if (e.touches.length === 1) {
                isPanning = false;
                startErase(e.touches[0]);
            }
        }
        const DECRYPT_KEY = "your-secret-key-2025";
        const BLOCK_SIZE = 128;

        function simpleHashU32(str) {
            let h = 5381;
            const bytes = new TextEncoder().encode(str);
            for (let i = 0; i < bytes.length; i++) {
                h = ((h * 33) ^ bytes[i]) >>> 0;
            }
            return h;
        }

        function simpleHashByte(str) {
            return simpleHashU32(str) & 0xFF;
        }

        function lcgNext(state) {
            return (1664525 * state + 1013904223) >>> 0;
        }

        function generatePerm(n, seed) {
            if (seed === 0) seed = 1;
            let state = seed;
            const perm = Array.from({ length: n }, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                state = lcgNext(state);
                const j = state % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }
            return perm;
        }

        async function decryptBlockImageData(imgData, width, height, key) {
            const data = imgData.data;
            const blockW = Math.floor(width / BLOCK_SIZE);   // ← 只处理完整块
            const blockH = Math.floor(height / BLOCK_SIZE);
            const totalBlocks = blockW * blockH;

            // 如果没有完整块，直接返回原图
            if (totalBlocks === 0) {
                return new ImageData(new Uint8ClampedArray(data), width, height);
            }

            const permSeed = simpleHashU32(key + "_block_perm");
            const perm = generatePerm(totalBlocks, permSeed);
            const invPerm = new Array(totalBlocks);
            for (let i = 0; i < totalBlocks; i++) {
                invPerm[perm[i]] = i;
            }

            const newData = new Uint8ClampedArray(data); // ← 先复制原数据，边缘不变

            for (let k = 0; k < totalBlocks; k++) {
                const i = invPerm[k];
                //const xorVal = simpleHashByte(key + `_xor_${i}`);
                const xorVal = 0;
                const srcX = (i % blockW) * BLOCK_SIZE;
                const srcY = Math.floor(i / blockW) * BLOCK_SIZE;
                const dstX = (k % blockW) * BLOCK_SIZE;
                const dstY = Math.floor(k / blockW) * BLOCK_SIZE;

                // 每块固定 128x128，无需裁剪
                for (let dy = 0; dy < BLOCK_SIZE; dy++) {
                    for (let dx = 0; dx < BLOCK_SIZE; dx++) {
                        const srcIdx = ((srcY + dy) * width + (srcX + dx)) * 4;
                        const dstIdx = ((dstY + dy) * width + (dstX + dx)) * 4;
                        newData[dstIdx]     = data[srcIdx]     ^ xorVal;
                        newData[dstIdx + 1] = data[srcIdx + 1] ^ xorVal;
                        newData[dstIdx + 2] = data[srcIdx + 2] ^ xorVal;
                        newData[dstIdx + 3] = data[srcIdx + 3]; // ← Alpha 不 XOR（可选，但推荐）
                    }
                }
            }
            return new ImageData(newData, width, height);
        }
        topCanvas.addEventListener('touchstart', handleTouchStart);
        topCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        topCanvas.addEventListener('touchend', handleTouchEnd);
        topCanvas.addEventListener('touchcancel', handleTouchEnd);
        topCanvas.addEventListener('mousedown', startErase);
        topCanvas.addEventListener('mousemove', continueErase);
        topCanvas.addEventListener('mouseup', stopErase);
        topCanvas.addEventListener('mouseleave', stopErase);
    </script>
</body>
</html>